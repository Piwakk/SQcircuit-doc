<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SQcircuit.circuit &mdash; SQcircuit 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=c4b7b015" />

  
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            SQcircuit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quick_tutorial.html">Quick Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/guides.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html#contributors">Contributors</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SQcircuit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">SQcircuit.circuit</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for SQcircuit.circuit</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;circuit.py contains the classes for the circuit and their properties</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Type</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Self</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="k">as</span> <span class="nn">qt</span>
<span class="kn">import</span> <span class="nn">scipy.special</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">import</span> <span class="nn">mpmath</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span> <span class="nn">qutip.qobj</span> <span class="kn">import</span> <span class="n">Qobj</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">sqrtm</span><span class="p">,</span> <span class="n">block_diag</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">eval_hermitenorm</span><span class="p">,</span> <span class="n">hyperu</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">ArpackNoConvergence</span>

<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">Tensor</span>

<span class="kn">import</span> <span class="nn">SQcircuit.units</span> <span class="k">as</span> <span class="nn">unt</span>
<span class="kn">import</span> <span class="nn">SQcircuit.functions</span> <span class="k">as</span> <span class="nn">sqf</span>
<span class="kn">import</span> <span class="nn">SQcircuit.torch_extensions</span> <span class="k">as</span> <span class="nn">sqtorch</span>

<span class="kn">from</span> <span class="nn">SQcircuit.elements</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Element</span><span class="p">,</span>
    <span class="n">Capacitor</span><span class="p">,</span>
    <span class="n">Inductor</span><span class="p">,</span>
    <span class="n">Junction</span><span class="p">,</span>
    <span class="n">Loop</span><span class="p">,</span>
    <span class="n">Charge</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">SQcircuit.texts</span> <span class="kn">import</span> <span class="n">HamilTxt</span><span class="p">,</span> <span class="n">is_notebook</span>
<span class="kn">from</span> <span class="nn">SQcircuit</span> <span class="kn">import</span> <span class="n">symbolic</span>
<span class="kn">from</span> <span class="nn">SQcircuit.noise</span> <span class="kn">import</span> <span class="n">ENV</span>
<span class="kn">from</span> <span class="nn">SQcircuit.settings</span> <span class="kn">import</span> <span class="n">ACC</span><span class="p">,</span> <span class="n">get_optim_mode</span>
<span class="kn">from</span> <span class="nn">SQcircuit.logs</span> <span class="kn">import</span> <span class="n">raise_optim_error_if_needed</span>


<span class="k">class</span> <span class="nc">CircuitEdge</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class that contains the properties of an edge in the circuit.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        circ:</span>
<span class="sd">            Circuit that edge is part of.</span>
<span class="sd">        edge:</span>
<span class="sd">            The tuple represents the edge of the circuit.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">circ</span><span class="p">:</span> <span class="s2">&quot;Circuit&quot;</span><span class="p">,</span>
        <span class="n">edge</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">circ</span> <span class="o">=</span> <span class="n">circ</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge</span> <span class="o">=</span> <span class="n">edge</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_w_at_edge</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat_rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_matrix_rep</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">edge_elems_by_type</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Capacitor</span><span class="p">:</span> <span class="p">[],</span>
            <span class="n">Inductor</span><span class="p">:</span> <span class="p">[],</span>
            <span class="n">Junction</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">}</span>

        <span class="c1"># check if edge is processed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_set_w_at_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the w_k vector as list at the edge.&quot;&quot;&quot;</span>

        <span class="c1"># i1 and i2 are the nodes of the edge</span>
        <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span>

        <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">i1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">w</span><span class="p">[</span><span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">w</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">_set_matrix_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Special form of matrix representation for an edge of a graph.</span>
<span class="sd">        This helps to construct the capacitance and susceptance matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">A</span>

    <span class="k">def</span> <span class="nf">update_circuit_loop_from_element</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">el</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Inductor</span><span class="p">,</span> <span class="n">Junction</span><span class="p">],</span>
        <span class="n">B_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update loop properties related to circuit from element in the edge</span>
<span class="sd">        with its inductive index (B_idx).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            el:</span>
<span class="sd">                Inductive element.</span>
<span class="sd">            B_idx:</span>
<span class="sd">                Inductive index.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">el</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">add_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">add_index</span><span class="p">(</span><span class="n">B_idx</span><span class="p">)</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">addK1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">add_to_parameters</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_edge_and_update_circ</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">B_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">W_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">K1</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
        <span class="n">c_edge_mat</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process the edge and update the related circuit properties.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            B_idx:</span>
<span class="sd">                Point to each row of B matrix of the circuit.</span>
<span class="sd">            W_idx:</span>
<span class="sd">                Point to each row of W matrix of the circuit.</span>
<span class="sd">            K1:</span>
<span class="sd">                Matrix related to loop calculation</span>
<span class="sd">            c_edge_mat:</span>
<span class="sd">                edge capacitance matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">]:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">edge_elems_by_type</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>

            <span class="c1"># Case of inductive element</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="s2">&quot;loops&quot;</span><span class="p">):</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">edge_elems_by_type</span><span class="p">[</span><span class="n">Capacitor</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">add_to_parameters</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="p">,</span> <span class="s2">&quot;partial_mat&quot;</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">partial_mats</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="o">.</span><span class="n">partial_mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat_rep</span><span class="p">)</span>
                        <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">el</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">update_circuit_loop_from_element</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)</span>

                <span class="n">B_idx</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">K1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>

                <span class="n">c_edge_mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">el</span><span class="o">.</span><span class="n">get_cap_for_flux_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">flux_dist</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Case of L and C</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="s2">&quot;partial_mat&quot;</span><span class="p">):</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">partial_mats</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">+=</span> <span class="n">el</span><span class="o">.</span><span class="n">partial_mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat_rep</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">circ</span><span class="o">.</span><span class="n">add_to_parameters</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">c_edge_mat</span>

    <span class="k">def</span> <span class="nf">_check_if_edge_is_processed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed</span><span class="p">,</span> <span class="s2">&quot;Edge is not processed yet!&quot;</span>

    <span class="k">def</span> <span class="nf">get_eff_cap_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return effective capacitor value of the edge.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_edge_is_processed</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">get_value</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_elems_by_type</span><span class="p">[</span><span class="n">Capacitor</span><span class="p">]</span>
        <span class="p">)))</span>

    <span class="k">def</span> <span class="nf">get_eff_ind_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return effective inductor value of the edge.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_edge_is_processed</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">l</span><span class="o">.</span><span class="n">get_value</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_elems_by_type</span><span class="p">[</span><span class="n">Inductor</span><span class="p">]</span>
        <span class="p">)))</span>

    <span class="k">def</span> <span class="nf">is_JJ_in_this_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the edge contains any JJ.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_edge_is_processed</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_elems_by_type</span><span class="p">[</span><span class="n">Junction</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">is_JJ_without_ind</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the edge only has JJ and no inductor.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_edge_is_processed</span><span class="p">()</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_elems_by_type</span><span class="p">[</span><span class="n">Junction</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_elems_by_type</span><span class="p">[</span><span class="n">Inductor</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">flag</span>


<div class="viewcode-block" id="Circuit">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit">[docs]</a>
<span class="k">class</span> <span class="nc">Circuit</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class that contains circuit properties and builds the Hamiltonian using</span>
<span class="sd">    the theory discussed in the original SQcircuit paper. Provides methods to</span>
<span class="sd">    calculate:</span>

<span class="sd">        * Eigenvalues and eigenvectors</span>
<span class="sd">        * Phase coordinate representation of eigenvectors</span>
<span class="sd">        * Coupling operators</span>
<span class="sd">        * Matrix elements</span>
<span class="sd">        * Decoherence rates</span>
<span class="sd">        * Gradients of Hamiltonian, eigenvalues/vectors , and Decoherence</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        elements:</span>
<span class="sd">            A dictionary that contains the circuit&#39;s elements at each edge</span>
<span class="sd">            of the circuit.</span>
<span class="sd">        flux_dist:</span>
<span class="sd">            Provide the method of distributing the external fluxes. If</span>
<span class="sd">            ``flux_dist`` is ``&quot;all&quot;``, SQcircuit assign the external fluxes</span>
<span class="sd">            based on the capacitor of each inductive element (This option is</span>
<span class="sd">            necessary for time-dependent external fluxes). If ``flux_dist`` is</span>
<span class="sd">            ``&quot;inductor&quot;`` SQcircuit finds the external flux distribution by</span>
<span class="sd">            assuming the capacitor of the inductors are much smaller than the</span>
<span class="sd">            junction capacitors, If ``flux_dist`` is ``&quot;junction&quot;`` it is the</span>
<span class="sd">            other way around.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Element</span><span class="p">]],</span>
        <span class="n">flux_dist</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;junctions&#39;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1">#######################################################################</span>
        <span class="c1"># General circuit attributes</span>
        <span class="c1">#######################################################################</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="n">elements</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="p">)</span>

        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;flux_dist option must be either </span><span class="se">\&quot;</span><span class="s2">junctions</span><span class="se">\&quot;</span><span class="s2">, &quot;</span>
                 <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">inductors</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">all</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">flux_dist</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;junctions&quot;</span><span class="p">,</span> <span class="s2">&quot;inductors&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_dist</span> <span class="o">=</span> <span class="n">flux_dist</span>

        <span class="c1"># circuit inductive loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Loop</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># number of nodes without ground</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">))</span>

        <span class="c1"># number of branches that contain JJ without parallel inductor.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1"># inductor element keys: (edge, el, B_idx) B_idx point to</span>
            <span class="c1"># each row of B matrix (external flux distribution of that element)</span>
            <span class="n">Inductor</span><span class="p">:</span> <span class="p">[],</span>
            <span class="c1"># junction element keys: (edge, el, B_idx, W_idx) B_idx point to</span>
            <span class="c1"># each row of B matrix (external flux distribution of that element)</span>
            <span class="c1"># and W_idx point to each row of W matrix</span>
            <span class="n">Junction</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="c1"># contains the parameters that we want to optimize.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span> <span class="n">OrderedDict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Element</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1">#######################################################################</span>
        <span class="c1"># Transformation related attributes</span>
        <span class="c1">#######################################################################</span>

        <span class="c1"># get the capacitance matrix, sudo-inductance matrix, W matrix,</span>
        <span class="c1"># and B matrix (loop distribution over inductive elements)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_LCWB</span><span class="p">()</span>

        <span class="c1"># initialize the transformation matrices for charge and flux operators.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># initialize transformed susceptance, inverse capacitance,</span>
        <span class="c1"># and W matrices.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)),</span>
            <span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># natural angular frequencies of the circuit for each mode as a numpy</span>
        <span class="c1"># array (zero for charge modes)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># transform the Hamiltonian of the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform_hamil</span><span class="p">()</span>

        <span class="c1"># charge islands of the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">Charge</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">#######################################################################</span>
        <span class="c1"># Operator and diagonalization related attributes</span>
        <span class="c1">#######################################################################</span>

        <span class="c1"># truncation numbers for each mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># squeezed truncation numbers (eliminating the modes with truncation</span>
        <span class="c1"># number equals 1)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">],</span>
                                          <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Q&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># list of charge operators (normalized by 1/sqrt(hbar))</span>
            <span class="s2">&quot;QQ&quot;</span><span class="p">:</span> <span class="p">[[]],</span>  <span class="c1"># list of charge times charge operators</span>
            <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># list of flux operators (normalized by 1/sqrt(hbar))</span>
            <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># list of number operators</span>
            <span class="s2">&quot;exp&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># List of exponential operators</span>
            <span class="s2">&quot;root_exp&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># List of square root of exponential operators</span>
            <span class="s2">&quot;cos&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># List of cosine operators</span>
            <span class="s2">&quot;sin&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># List of sine operators</span>
            <span class="s2">&quot;sin_half&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># list of sin(phi/2)</span>
            <span class="s2">&quot;ind_hamil&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># list of w^T*phi that appears in Hamiltonian</span>
        <span class="p">}</span>

        <span class="c1"># TODO: fix typing; add comments etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;omega&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;phi_zp&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;ng&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;EC&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;EJ&quot;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>

        <span class="c1"># LC part of the Hamiltonian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LC_hamil</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="c1"># eigenvalues of the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="c1"># eigenvectors of the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Toggle whether we need to copy all elements (namely the</span>
        <span class="c1"># _memory_ops and _LC_hamil; see .__getstate__)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_toggle_fullcopy</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Circuit.update">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.update">[docs]</a>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the circuit Hamiltonian to reflect in-place changes made to</span>
<span class="sd">        the scalar values used for circuit elements (ex. C, L, J...).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Inductor</span><span class="p">:</span> <span class="p">[],</span>
            <span class="n">Junction</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Loop</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
          
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_LCWB</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)),</span>
            <span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform_hamil</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Q&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># list of charge operators (normalized by 1/sqrt(hbar))</span>
            <span class="s2">&quot;QQ&quot;</span><span class="p">:</span> <span class="p">[[]],</span>  <span class="c1"># list of charge times charge operators</span>
            <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># list of flux operators (normalized by 1/sqrt(hbar))</span>
            <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># list of number operators</span>
            <span class="s2">&quot;exp&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># List of exponential operators</span>
            <span class="s2">&quot;root_exp&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># List of square root of exponential operators</span>
            <span class="s2">&quot;cos&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># List of cosine operators</span>
            <span class="s2">&quot;sin&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># List of sine operators</span>
            <span class="s2">&quot;sin_half&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># list of sin(phi/2)</span>
            <span class="s2">&quot;ind_hamil&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># list of w^T*phi that appears in Hamiltonian</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_build_op_memory</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LC_hamil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_LC_hamil</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_exp_ops</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span> <span class="o">=</span> <span class="p">[]</span></div>


    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

        <span class="c1"># When ``_toggle_fullcopy`` is ``False``, remove attributes of the</span>
        <span class="c1"># circuit which cost a lot of memory but can be reconstructed by calling</span>
        <span class="c1"># ``.update()``. Useful when pickling a copy of the circuit.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toggle_fullcopy</span><span class="p">:</span>
            <span class="n">avoid_attrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">avoid_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_memory_ops&quot;</span><span class="p">,</span> <span class="s2">&quot;_LC_hamil&quot;</span><span class="p">]</span>

        <span class="n">self_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">avoid_attrs</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">self_dict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">state</span>
        <span class="c1"># Set ``_toggle_fullcopy`` back to ``True`` because this is the default</span>
        <span class="c1"># state when initializing a circuit, but is often set to ``False`` when</span>
        <span class="c1"># pickling the circuit.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_toggle_fullcopy</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">efreqs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Eigenfrequencies in the chosen frequency unit for SQcircuit. If the</span>
<span class="sd">        SQcircuit engine is ``PyTorch``, the efreqs will be in ``Tensor``</span>
<span class="sd">        format; otherwise, they will be in ``ndarray`` format.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Please diagonalize the circuit first.&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">evecs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of circuit eigenvectors. If the SQcircuit engine is ``PyTorch``,</span>
<span class="sd">        each eigenvector will be in ``Tensor`` format; otherwise, they will be</span>
<span class="sd">        in ``Qutip.Qobj`` format.&quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Please diagonalize the circuit first.&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trunc_nums</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of truncation numbers of the circuit. For harmonic modes, these</span>
<span class="sd">        are N where the Hilbert space is 0, 1, …, (N-1) and for charge modes</span>
<span class="sd">        these are N where the Hilbert space is -(N-1), …, 0, …, (N-1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trunc_nums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">trunc_nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">trunc_nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">trunc_nums</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The values of the elements in the circuit which require gradient.</span>
<span class="sd">        The parameters can be set by a list of new values for each of the</span>
<span class="sd">        elements. Only valid if ``get_optim_mode() = True`` or we are</span>
<span class="sd">        using ``PyTorch`` engine of SQcircuit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_optim_error_if_needed</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_params</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">element</span><span class="o">.</span><span class="n">internal_value</span> <span class="o">=</span> <span class="n">new_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]],</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the gradients of the tensors in ``.parameters``. If all values</span>
<span class="sd">        are not ``None``, it is returned as a stacked ``Tensor``, otherwise as a</span>
<span class="sd">        list of individual values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_optim_error_if_needed</span><span class="p">()</span>

        <span class="n">grad_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="n">grad_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span>

        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">grad_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grad_list</span>

        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">grad_list</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters_dict</span><span class="p">(</span>
            <span class="bp">self</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OrderedDict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Element</span><span class="p">,</span> <span class="n">Loop</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The dictionary of (element, value) pairs for the elements in</span>
<span class="sd">        the circuit which require gradient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Element</span><span class="p">,</span> <span class="n">Loop</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The elements in the circuit which require gradient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<div class="viewcode-block" id="Circuit.get_params_type">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.get_params_type">[docs]</a>
    <span class="k">def</span> <span class="nf">get_params_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Element</span><span class="p">],</span> <span class="n">Type</span><span class="p">[</span><span class="n">Loop</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of the types for each element in the circuit&#39;s parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">elements_flattened</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">params_type</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements_flattened</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">params_type</span></div>


<div class="viewcode-block" id="Circuit.zero_parameters_grad">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.zero_parameters_grad">[docs]</a>
    <span class="k">def</span> <span class="nf">zero_parameters_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the gradient of all values in `self.parameters` to `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_optim_error_if_needed</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="n">val</span><span class="o">.</span><span class="n">grad</span><span class="o">=</span><span class="kc">None</span></div>


    <span class="k">def</span> <span class="nf">add_to_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">el</span><span class="p">:</span> <span class="n">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an element with ``requires_grad=True`` to parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            el:</span>
<span class="sd">                An element to add to ``.parameters``, if the element requires</span>
<span class="sd">                gradient and is not already present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">requires_grad</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">el</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">)</span> <span class="ow">and</span> <span class="n">el</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">internal_value</span>


    <span class="k">def</span> <span class="nf">add_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">:</span> <span class="n">Loop</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add loop to the circuit loops.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            loop:</span>
<span class="sd">                Loop in the circuit to add to ``.loops``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">loop</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>

<div class="viewcode-block" id="Circuit.safecopy">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.safecopy">[docs]</a>
    <span class="k">def</span> <span class="nf">safecopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save_eigs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of ``self``, explicitly detaching and cloning all</span>
<span class="sd">        tensor values in the circuit (which are element and loop values).</span>
<span class="sd">        Eigenvalues/vectors are either discarded or detached and cloned based</span>
<span class="sd">        on the value of ``save_eigs``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            save_eigs:</span>
<span class="sd">                Whether to retain the eigenvalues/vectors in the copied version</span>
<span class="sd">                of the circuit.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Deepcopy of `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Instantiate new container</span>
        <span class="n">new_circuit</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># When `get_optim_mode()`, SQcircuit contains many tensor values, which</span>
        <span class="c1"># may not be leafs. These don&#39;t implement a deepcopy method, so</span>
        <span class="c1"># need to be explicitly detached/cloned.</span>
        <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>
            <span class="c1"># Capacitance and inductance matrices are constructed from</span>
            <span class="c1"># element values</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">new_circuit</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">new_circuit</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

            <span class="c1"># Replace all loops in circuit with identically-valued copies</span>
            <span class="c1"># whose `.internal_value`s are cloned.</span>
            <span class="n">new_loops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Loop</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">replacement_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Loop</span><span class="p">,</span> <span class="n">Element</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">Loop</span><span class="p">,</span> <span class="n">Element</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
                <span class="n">new_loop</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
                <span class="n">new_loop</span><span class="o">.</span><span class="n">internal_value</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">internal_value</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="n">new_loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_loop</span><span class="p">)</span>
                <span class="n">replacement_dict</span><span class="p">[</span><span class="n">loop</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_loop</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">loops</span> <span class="o">=</span> <span class="n">new_loops</span>

            <span class="c1"># Replace all elements in circuit with identically-valued copies</span>
            <span class="c1"># whose `.internal_value`s are cloned.</span>
            <span class="n">new_elements</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">edge</span><span class="p">]:</span>
                    <span class="n">new_el</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                    <span class="n">new_el</span><span class="o">.</span><span class="n">internal_value</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">internal_value</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                    <span class="c1"># Need to also replace loops associated with circuit</span>
                    <span class="c1"># with the new copies.</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="s1">&#39;loops&#39;</span><span class="p">):</span>
                        <span class="n">new_loops</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">el</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
                            <span class="n">new_loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replacement_dict</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                        <span class="n">new_el</span><span class="o">.</span><span class="n">loops</span> <span class="o">=</span> <span class="n">new_loops</span>
                    <span class="n">new_elements</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_el</span><span class="p">)</span>

                    <span class="n">replacement_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_el</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">new_elements</span>

            <span class="c1"># Replace the parameters dict with the copied elements</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
                <span class="n">new_el</span> <span class="o">=</span> <span class="n">replacement_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span>
                <span class="n">new_circuit</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">new_el</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_el</span><span class="o">.</span><span class="n">internal_value</span>

            <span class="c1"># Several operators in SQcircuit are saved in dictionaries</span>
            <span class="c1"># indexed by element. These keys all need to be updated to use</span>
            <span class="c1"># the copied elements.</span>

            <span class="c1"># Update the `.elem_keys` dictionary</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">elem_keys</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">Inductor</span><span class="p">:</span> <span class="p">[],</span>
                <span class="n">Junction</span><span class="p">:</span> <span class="p">[],</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Junction</span><span class="p">]:</span>
                <span class="n">new_el</span> <span class="o">=</span> <span class="n">replacement_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span>
                <span class="n">new_circuit</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Junction</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">edge</span><span class="p">,</span> <span class="n">new_el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Inductor</span><span class="p">]:</span>
                <span class="n">new_el</span> <span class="o">=</span> <span class="n">replacement_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span>
                <span class="n">new_circuit</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Inductor</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">edge</span><span class="p">,</span> <span class="n">new_el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">))</span>

            <span class="c1"># Update the `.partial_mats` dictionary</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">partial_mats</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">partial_mat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_mats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">new_circuit</span><span class="o">.</span><span class="n">partial_mats</span><span class="p">[</span><span class="n">replacement_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]]</span> <span class="o">=</span> <span class="n">partial_mat</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">new_circuit</span><span class="o">.</span><span class="n">partial_mats</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial_mat</span>

            <span class="c1"># Update the `.memory_ops` dictionary.</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">_memory_ops</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># Some operators contain dictionaries indexed by elements; the</span>
            <span class="c1"># others are fine.</span>
            <span class="n">problem_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">,</span> <span class="s1">&#39;sin&#39;</span><span class="p">,</span> <span class="s1">&#39;sin_half&#39;</span><span class="p">,</span> <span class="s1">&#39;ind_hamil&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">op_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">op_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">problem_types</span><span class="p">:</span>
                    <span class="n">new_circuit</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="n">op_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="n">op_type</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_circuit</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="n">op_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="n">op_type</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">new_circuit</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="n">op_type</span><span class="p">][(</span><span class="n">replacement_dict</span><span class="p">[</span><span class="n">el</span><span class="p">],</span> <span class="n">B_idx</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="n">op_type</span><span class="p">][(</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)]</span>
                        <span class="p">)</span>

        <span class="c1"># Remove old eigenvectors/values, if desired</span>
        <span class="k">if</span> <span class="n">save_eigs</span><span class="p">:</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">_efreqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">_evecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">_efreqs</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">_evecs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Delete the `.descrip_vars`, because bug in the `ExplicitSymbol` class</span>
        <span class="c1"># prevents native `deepcopy`ing.</span>
        <span class="n">new_circuit</span><span class="o">.</span><span class="n">descrip_vars</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Deepcopy the whole thing, now that problematic attributes have been</span>
        <span class="c1"># explicitly taken care of.</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">new_circuit</span><span class="p">)</span></div>


<div class="viewcode-block" id="Circuit.picklecopy">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.picklecopy">[docs]</a>
    <span class="k">def</span> <span class="nf">picklecopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function which returns a shallow copy of ``self`` with</span>
<span class="sd">        ``._toggle_fullcopy = False``. Use for pickling circuit to save memory.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Copy of self with ``._toggle_fullcopy = False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
       <span class="c1"># Instantiate new container</span>
        <span class="n">new_circuit</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Remove large objects when saving</span>
        <span class="n">new_circuit</span><span class="o">.</span><span class="n">_toggle_fullcopy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">new_circuit</span></div>


    <span class="k">def</span> <span class="nf">_get_LCWB</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the capacitance matrix, sustenance matrix, W matrix,</span>
<span class="sd">        and the flux distribution over inductive elements B matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            A tuple of the (capacitance, susceptance, W, B) matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cMat</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">lMat</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">wMat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bMat</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">partial_mats</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># point to each row of B matrix (external flux distribution of that</span>
        <span class="c1"># element) or count the number of inductive elements.</span>
        <span class="n">B_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># W_idx point to each row of W matrix for junctions or count the</span>
        <span class="c1"># number of edges contain JJ</span>
        <span class="n">W_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># number of branches that contain JJ without parallel inductor.</span>
        <span class="n">countJJnoInd</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># K1 is a matrix that transfers node coordinates to the edge phase drop</span>
        <span class="c1"># for inductive elements</span>
        <span class="n">K1</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># capacitor at each inductive elements</span>
        <span class="n">c_edge_mat</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="n">circ_edge</span> <span class="o">=</span> <span class="n">CircuitEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>

            <span class="n">B_idx</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">c_edge_mat</span> <span class="o">=</span> <span class="n">circ_edge</span><span class="o">.</span><span class="n">process_edge_and_update_circ</span><span class="p">(</span>
                <span class="n">B_idx</span><span class="p">,</span>
                <span class="n">W_idx</span><span class="p">,</span>
                <span class="n">K1</span><span class="p">,</span>
                <span class="n">c_edge_mat</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">circ_edge</span><span class="o">.</span><span class="n">is_JJ_without_ind</span><span class="p">():</span>
                <span class="n">countJJnoInd</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">cMat</span> <span class="o">+=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">circ_edge</span><span class="o">.</span><span class="n">get_eff_cap_value</span><span class="p">())</span> <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">circ_edge</span><span class="o">.</span><span class="n">mat_rep</span><span class="p">)</span>

            <span class="n">lMat</span> <span class="o">+=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">circ_edge</span><span class="o">.</span><span class="n">get_eff_ind_value</span><span class="p">())</span> <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">circ_edge</span><span class="o">.</span><span class="n">mat_rep</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">circ_edge</span><span class="o">.</span><span class="n">is_JJ_in_this_edge</span><span class="p">():</span>
                <span class="n">wMat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circ_edge</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
                <span class="n">W_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">wMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wMat</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">K1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">K1</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">K1</span><span class="p">)</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K1</span> <span class="o">!=</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="c1"># eliminate the zero columns</span>
            <span class="n">K1</span> <span class="o">=</span> <span class="n">K1</span><span class="p">[:,</span> <span class="n">select</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">K1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">K1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">K1</span> <span class="o">=</span> <span class="n">K1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">X</span> <span class="o">=</span> <span class="n">K1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="n">c_edge_mat</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">))</span>
                <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">loop</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">getP</span><span class="p">()</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># number of inductive loops of the circuit</span>
            <span class="n">n_loops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_loops</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">B_idx</span> <span class="o">-</span> <span class="n">n_loops</span><span class="p">,</span> <span class="n">n_loops</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_loops</span><span class="p">)),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">bMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">@</span> <span class="n">Y</span>
                <span class="n">bMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">bMat</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The edge list does not specify a connected graph or &quot;</span>
                  <span class="s2">&quot;all inductive loops of the circuit are not specified.&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span> <span class="o">=</span> <span class="n">countJJnoInd</span>

        <span class="k">return</span> <span class="n">cMat</span><span class="p">,</span> <span class="n">lMat</span><span class="p">,</span> <span class="n">wMat</span><span class="p">,</span> <span class="n">bMat</span>

    <span class="k">def</span> <span class="nf">_is_charge_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the mode is a charge mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            i:</span>
<span class="sd">                index of the mode. (starts from zero for the first mode)</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Whether the ``i``th mode is a charge mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply S and R transformation on transformed C, L, and W matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            S:</span>
<span class="sd">                Transformation matrices related to flux operators.</span>
<span class="sd">            R:</span>
<span class="sd">                Transformation matrices related to charge operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span> <span class="o">@</span> <span class="n">R</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span> <span class="o">@</span> <span class="n">S</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span> <span class="o">@</span> <span class="n">S</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">@</span> <span class="n">S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">@</span> <span class="n">R</span>

    <span class="k">def</span> <span class="nf">_get_and_apply_transformation_1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get and apply the first transformation of the coordinates that</span>
<span class="sd">        simultaneously diagonalizes the capacitance and susceptance matrices.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            A tuple of the (S1, R1) matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cMatRoot</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">))</span>
        <span class="n">cMatRootInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cMatRoot</span><span class="p">)</span>
        <span class="n">lMatRoot</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">))</span>

        <span class="n">V</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">lMatRoot</span> <span class="o">@</span> <span class="n">cMatRootInv</span><span class="p">)</span>

        <span class="c1"># the case that there is not any inductor in the circuit</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
            <span class="n">singLoc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># find the number of singularity in the circuit</span>

            <span class="n">lEig</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">))</span>
            <span class="n">numSing</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lEig</span><span class="p">[</span><span class="n">lEig</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lEig</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ACC</span><span class="p">[</span><span class="s2">&quot;sing_mode_detect&quot;</span><span class="p">]])</span>
            <span class="n">singLoc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">numSing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
            <span class="n">D</span><span class="p">[</span><span class="n">singLoc</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

        <span class="c1"># build S1 and R1 matrix</span>
        <span class="n">S1</span> <span class="o">=</span> <span class="n">cMatRootInv</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
        <span class="n">R1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_transformation</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">R1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">singLoc</span><span class="p">,</span> <span class="n">singLoc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">S1</span><span class="p">,</span> <span class="n">R1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_independent_rows</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use the Gram–Schmidt process to find the linear independent rows of </span>
<span class="sd">        matrix A and return the list of row indices of A and list of the rows.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            A:</span>
<span class="sd">                ``np.ndarray`` matrix that we try to find its independent</span>
<span class="sd">                rows.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The list of indices of linearly independent rows of ``A`` and a</span>
<span class="sd">            basis for the row space of ``A``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># normalize the rows of matrix A</span>
        <span class="n">A_norm</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-9</span><span class="p">)</span>

        <span class="c1"># Get the row of each A that has the highest norm in descending order.</span>
        <span class="c1"># This is important for the case of JJ capacitively coupled to JL.</span>
        <span class="n">sorted_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">idx_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sorted_index</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">A_norm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">a_prime</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="o">*</span> <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a_prime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ACC</span><span class="p">[</span><span class="s2">&quot;Gram–Schmidt&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">idx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_prime</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a_prime</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">idx_list</span><span class="p">,</span> <span class="n">basis</span>

    <span class="k">def</span> <span class="nf">_round_to_zero_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Round the charge mode elements of W or transformed W matrix that</span>
<span class="sd">        are close to 0, -1, and 1 to the exact value of 0, -1, and 1</span>
<span class="sd">        respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            W:</span>
<span class="sd">                ``np.ndarray`` that can be either W or transformed W matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            A rounded copy of ``W``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rounded_W</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rounded_W</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">charge_only_W</span> <span class="o">=</span> <span class="n">rounded_W</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">charge_only_W</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">charge_only_W</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ACC</span><span class="p">[</span><span class="s2">&quot;Gram–Schmidt&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">charge_only_W</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">charge_only_W</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ACC</span><span class="p">[</span><span class="s2">&quot;Gram–Schmidt&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">charge_only_W</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">charge_only_W</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ACC</span><span class="p">[</span><span class="s2">&quot;Gram–Schmidt&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">rounded_W</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">charge_only_W</span>

        <span class="k">return</span> <span class="n">rounded_W</span>

    <span class="k">def</span> <span class="nf">_is_Gram_Schmidt_successful</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the Gram_Schmidt process has the sufficient accuracy for</span>
<span class="sd">        the ``S`` transformation matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            S:</span>
<span class="sd">                Transformation matrix related to flux operators.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            True if the Gram-Schmidt succeeded</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">is_successful</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># absolute value of the current wTrans</span>
        <span class="n">cur_wTrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span> <span class="o">@</span> <span class="n">S</span>

        <span class="n">cur_wTrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round_to_zero_one</span><span class="p">(</span><span class="n">cur_wTrans</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">abs_w</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cur_wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">abs_w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">abs_w</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">is_successful</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">is_successful</span>

    <span class="k">def</span> <span class="nf">_is_junction_in_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if there are any Josephson junctions in the circuit.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            True if the circuit contains Josephson junctions, false otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_get_and_apply_transformation_2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get and apply the second transformation of the coordinates that</span>
<span class="sd">        transforms the subspace of the charge operators in order to have the</span>
<span class="sd">        reciprocal primitive vectors in Cartesian direction.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            A tuple of the (S2, R2) transformation matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># get the charge basis part of the wTrans matrix</span>
            <span class="n">wQ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># number of operators represented in charge bases</span>
            <span class="n">nq</span> <span class="o">=</span> <span class="n">wQ</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nq</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">wQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># if we need to represent an operator in charge basis</span>
        <span class="k">if</span> <span class="n">nq</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># list of indices of w vectors that are independent</span>
            <span class="n">indList</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># use Gram–Schmidt to find the linear independent rows of</span>
            <span class="c1"># normalized wQ (wQ_norm)</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nq</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">indList</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_independent_rows</span><span class="p">(</span><span class="n">wQ</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># to complete the basis</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nq</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">),</span> <span class="n">nq</span><span class="p">))</span>
                    <span class="n">basisComplete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">basis</span> <span class="o">+</span> <span class="n">X</span><span class="p">)</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_independent_rows</span><span class="p">(</span><span class="n">basisComplete</span><span class="p">)</span>

            <span class="c1"># the second S and R matrix are:</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">wQ</span><span class="p">[</span><span class="n">indList</span><span class="p">,</span> <span class="p">:])</span> <span class="o">+</span> <span class="n">X</span><span class="p">)</span>
            <span class="n">S2</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">nq</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">F</span><span class="p">))</span>

            <span class="n">R2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">S2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="n">R2</span> <span class="o">=</span> <span class="n">S2</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_Gram_Schmidt_successful</span><span class="p">(</span><span class="n">S2</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_transformation</span><span class="p">(</span><span class="n">S2</span><span class="p">,</span> <span class="n">R2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round_to_zero_one</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">S2</span><span class="p">,</span> <span class="n">R2</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Gram_Schmidt process failed. Retrying...&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_and_apply_transformation_2</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_and_apply_transformation_3</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get and apply the third transformation of the coordinates </span>
<span class="sd">        that scales the modes.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            A tuple of the (S3, R3) transformation matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">S3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="c1"># already scaled by second transformation</span>
                <span class="k">continue</span>

            <span class="c1"># for harmonic modes</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_junction_in_circuit</span><span class="p">():</span>

                <span class="c1"># note: alpha here is absolute value of alpha (alpha is pure</span>
                <span class="c1"># imaginary)</span>
                <span class="c1"># get alpha for j-th mode</span>
                <span class="n">jth_alphas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">j</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">][</span><span class="n">jth_alphas</span> <span class="o">&lt;</span> <span class="n">ACC</span><span class="p">[</span><span class="s2">&quot;har_mode_elim&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">jth_alphas</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ACC</span><span class="p">[</span><span class="s2">&quot;har_mode_elim&quot;</span><span class="p">]:</span>
                    <span class="c1"># find the coefficient in wTrans for j-th mode that</span>
                    <span class="c1"># has maximum alpha</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">jth_alphas</span><span class="p">),</span> <span class="n">j</span><span class="p">])</span>
                    <span class="n">S3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># scale the uncoupled mode</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]))</span>
                    <span class="n">S3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># scale the uncoupled mode</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="n">S3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s</span>

        <span class="n">R3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S3</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_transformation</span><span class="p">(</span><span class="n">S3</span><span class="p">,</span> <span class="n">R3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S3</span><span class="p">,</span> <span class="n">R3</span>

    <span class="k">def</span> <span class="nf">_transform_hamil</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform the Hamiltonian of the circuit into the charge and Fock</span>
<span class="sd">        bases.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the first transformation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_and_apply_transformation_1</span><span class="p">()</span>

        <span class="c1"># natural frequencies of the circuit(zero for modes in charge basis)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_junction_in_circuit</span><span class="p">():</span>
            <span class="c1"># get the second transformation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_and_apply_transformation_2</span><span class="p">()</span>

        <span class="c1"># scaling the modes by third transformation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_and_apply_transformation_3</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_compute_params</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute parameters of transformed Hamiltonian to reduced number</span>
<span class="sd">        of significant figures and in the frequency units of ``SQcircuit``;</span>
<span class="sd">        store in the ``.descrip_vars`` dictionary for easy access.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># dimensions of modes of circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;n_modes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;har_dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">har_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;har_dim&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;charge_dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> \
                                        <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;phi_zp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span><span class="p">)</span> \
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">)[:</span><span class="n">har_dim</span><span class="p">]</span>
                                        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">)[:</span><span class="n">har_dim</span><span class="p">])))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;ng&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> \
                                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">har_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;EC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">e</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> \
                                       <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">()))</span> \
                                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span> \
                                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;W&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Junction</span><span class="p">])</span>
                          <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Inductor</span><span class="p">]),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;EJ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Junction</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;EJ&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span> <span class="o">/</span> \
                                            <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;EL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;EL_incl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Inductor</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;EL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">_unit_ind</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;EL_incl&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">][</span><span class="n">B_idx</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;EC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;har_dim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;n_modes&#39;</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;n_modes&#39;</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;EC&#39;</span><span class="p">][(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span>  <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">e</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span> \
                                <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">())</span> <span class="o">*</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;EC&#39;</span><span class="p">][(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">/=</span> <span class="mi">2</span>

        <span class="c1"># values of loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;n_loops&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;loops&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> \
                                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">))]</span>

<div class="viewcode-block" id="Circuit.description">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.description">[docs]</a>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_test</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print out Hamiltonian and a listing of the modes (whether they are</span>
<span class="sd">        harmonic or charge modes with the frequency for each harmonic mode),</span>
<span class="sd">        Hamiltonian parameters, and external flux values. Constructs a</span>
<span class="sd">        symbolic Hamiltonian, which is stored in `.descrip_vars[&#39;H&#39;]`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            tp:</span>
<span class="sd">                If ``None`` prints out the output as Latex if SQcircuit is</span>
<span class="sd">                running in a Jupyter notebook and as text if SQcircuit is</span>
<span class="sd">                running in Python terminal. If ``tp`` is ``&quot;ltx&quot;``,</span>
<span class="sd">                the output is in Latex format, and if ``tp`` is ``&quot;txt&quot;`` the</span>
<span class="sd">                output is in text format.</span>
<span class="sd">            _test:</span>
<span class="sd">                if True, return the entire description as string</span>
<span class="sd">                text (use only for testing the function).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The text of the description as a string, if ``_test`` is ``True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_notebook</span><span class="p">():</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="n">HamilTxt</span><span class="p">(</span><span class="s1">&#39;ltx&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="n">HamilTxt</span><span class="p">(</span><span class="s1">&#39;txt&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="n">HamilTxt</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_params</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbolic</span><span class="o">.</span><span class="n">construct_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">final_txt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">print_circuit_description</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descrip_vars</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_test</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_txt</span></div>


<div class="viewcode-block" id="Circuit.loop_description">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.loop_description">[docs]</a>
    <span class="k">def</span> <span class="nf">loop_description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_test</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print out the external flux distribution over inductive elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            _test:</span>
<span class="sd">                if True, return the entire description as string</span>
<span class="sd">                text. (use only for testing the function)</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The text of the external flux distribution, if ``_test`` is</span>
<span class="sd">            ``True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loop_description_txt</span> <span class="o">=</span> <span class="n">HamilTxt</span><span class="o">.</span><span class="n">print_loop_description</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_test</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loop_description_txt</span></div>


<div class="viewcode-block" id="Circuit.set_trunc_nums">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.set_trunc_nums">[docs]</a>
    <span class="k">def</span> <span class="nf">set_trunc_nums</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the truncation numbers for each mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            nums:</span>
<span class="sd">                A list that contains the truncation numbers for each mode.</span>
<span class="sd">                Harmonic modes with truncation number N are 0, 1 , ...,</span>
<span class="sd">                (N-1), and charge modes with truncation number N are -(N-1),</span>
<span class="sd">                ..., 0, ..., (N-1).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;set_trunc_nums called&quot;</span><span class="p">)</span>
        <span class="n">error1</span> <span class="o">=</span> <span class="s2">&quot;The input must be be a python list&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="n">error1</span>
        <span class="n">error2</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The number of modes (length of the input) must be equal to &quot;</span>
                  <span class="s2">&quot;the number of nodes&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">error2</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># for charge modes:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># for harmonic modes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># squeeze the mode with truncation number equal to 1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_build_op_memory</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_LC_hamil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_LC_hamil</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_build_exp_ops</span><span class="p">()</span></div>


<div class="viewcode-block" id="Circuit.set_charge_offset">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.set_charge_offset">[docs]</a>
    <span class="k">def</span> <span class="nf">set_charge_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ng</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the charge offset for each charge mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mode:</span>
<span class="sd">                An integer that specifies the charge mode. To see, which mode</span>
<span class="sd">                is a charge mode, one can use ``description()`` method.</span>
<span class="sd">            ng:</span>
<span class="sd">                The charge offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;Mode number should be an integer&quot;</span>

        <span class="n">error</span> <span class="o">=</span> <span class="s2">&quot;The specified mode is not a charge mode.&quot;</span>
        <span class="k">assert</span> <span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">,</span> <span class="n">error</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setOffset</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setOffset</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_build_op_memory</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_LC_hamil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_LC_hamil</span><span class="p">()</span></div>


<div class="viewcode-block" id="Circuit.set_charge_noise">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.set_charge_noise">[docs]</a>
    <span class="k">def</span> <span class="nf">set_charge_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the charge noise for each charge mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mode:</span>
<span class="sd">                An integer that specifies the charge mode. To see which mode</span>
<span class="sd">                is a charge mode, we can use ``description()`` method.</span>
<span class="sd">            A:</span>
<span class="sd">                The charge noise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;Mode number should be an integer&quot;</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;The specified mode is not a charge mode.&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setNoise</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_op_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the operator dims related to ``Qutip.Qobj``.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_state_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the state dims related to ``Qutip.Qobj``.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">_squeeze_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="n">Qobj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the same Quantum operator with squeezed dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            op:</span>
<span class="sd">                Any quantum operator in qutip.Qobj format</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            A squeezed copy of ``op``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">op_sq</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

        <span class="n">op_sq</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_dims</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">op_sq</span>

    <span class="k">def</span> <span class="nf">_charge_op_isolated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return charge operator for each isolated mode normalized by</span>
<span class="sd">        square root of hbar. By isolated, we mean that the operator is not in</span>
<span class="sd">        the general tensor product states of the overall system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            i:</span>
<span class="sd">                Index of the mode. (starts from zero for the first mode)</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The isolated charge operator for the ``i``th mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">ng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
            <span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">unt</span><span class="o">.</span><span class="n">e</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">charge</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">ng</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">Q_zp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="o">/</span><span class="n">Z</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Q_zp</span> <span class="o">*</span> <span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">qt</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">op</span>

    <span class="k">def</span> <span class="nf">_flux_op_isolated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return flux operator for each isolated mode normalized by</span>
<span class="sd">        square root of hbar. By isolated, we mean that the operator is not in</span>
<span class="sd">        the general tensor product states of the overall system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            i:</span>
<span class="sd">                Index of the mode. (starts from zero for the first mode)</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The isolated flux operator for the ``i``th mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">op</span>

    <span class="k">def</span> <span class="nf">_num_op_isolated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return number operator for each isolated mode. By isolated,</span>
<span class="sd">        we mean that the operator is not in the general tensor product states</span>
<span class="sd">        of the overall system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            i:</span>
<span class="sd">                Index of the mode. (starts from zero for the first mode)</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The isolated number operator for the ``i``th mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">charge</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">op</span>

    <span class="k">def</span> <span class="nf">_d_op_isolated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return charge displacement operator for each isolated mode. By</span>
<span class="sd">        isolated, we mean that the operator is not in the general tensor</span>
<span class="sd">        product states of the overall system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            i:</span>
<span class="sd">                Index of the mode. (starts from zero for the first mode)</span>
<span class="sd">            w:</span>
<span class="sd">                Represent the power of the displacement operator, d^w. Right</span>
<span class="sd">                now w should be only 0, 1, and -1.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The isolated charge displacement operator for the ``i``th mode, to </span>
<span class="sd">            the power of ``w``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>

        <span class="k">elif</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">range</span><span class="p">],</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the alpha, amount of displacement, for the bosonic</span>
<span class="sd">        displacement operator for junction i and mode j.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            i:</span>
<span class="sd">                Index of the Junction. (starts from zero for the first mode)</span>
<span class="sd">            j:</span>
<span class="sd">                Index of the mode. (starts from zero for the first mode)</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The value of alpha for the junction ``i`` and mode ``j``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

        <span class="n">coef</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>

        <span class="k">return</span> <span class="n">coef</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_build_op_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the charge, flux, number, and cross multiplication of charge</span>
<span class="sd">        operators and store them in memory related to operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">charge_ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">flux_ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">charge_by_charge_ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>

            <span class="n">Q</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">charges_row</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">num</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">Q_iso</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_charge_op_isolated</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">Q2</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">+</span> <span class="p">[</span><span class="n">Q_iso</span> <span class="o">*</span> <span class="n">Q_iso</span><span class="p">]</span>
                    <span class="c1"># append the rest with qeye.</span>
                    <span class="n">Q2</span> <span class="o">+=</span> <span class="p">[</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>
                    <span class="n">charges_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="n">Q2</span><span class="p">)))</span>

                    <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q_iso</span><span class="p">)</span>
                    <span class="n">num</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_op_isolated</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
                    <span class="n">flux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_op_isolated</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">QQ</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_charge_op_isolated</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span>
                        <span class="c1"># append the rest with qeye.</span>
                        <span class="n">QQ</span> <span class="o">+=</span> <span class="p">[</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>
                        <span class="n">charges_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="n">QQ</span><span class="p">)))</span>

                    <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                    <span class="n">num</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                    <span class="n">flux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

            <span class="n">charge_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="n">Q</span><span class="p">)))</span>
            <span class="n">num_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="n">num</span><span class="p">)))</span>
            <span class="n">flux_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="n">flux</span><span class="p">)))</span>
            <span class="n">charge_by_charge_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">charges_row</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">charge_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;QQ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">charge_by_charge_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_ops</span>

    <span class="k">def</span> <span class="nf">_build_exp_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build exponential operators needed to construct cosine potential of</span>
<span class="sd">        the Josephson Junctions and store them in memory related to operators.</span>
<span class="sd">        Note that cosine of JJs can be written as summation of two</span>
<span class="sd">        exponential terms,cos(x)=(exp(ix)+exp(-ix))/2. This function builds</span>
<span class="sd">        the quantum operators for only one exponential terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># list of exp operators</span>
        <span class="n">exp_ops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># list of square root of exp operators</span>
        <span class="n">root_exp_ops</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># number of Josephson Junctions</span>
        <span class="n">nJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nJ</span><span class="p">):</span>

            <span class="c1"># list of isolated exp operators</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># list of isolated square root of exp operators</span>
            <span class="n">exp_h</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># tensor multiplication of displacement operator for JJ Hamiltonian</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="n">exp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_op_isolated</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                    <span class="n">exp_h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)))</span>
                    <span class="n">exp_h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

            <span class="n">exp_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="n">exp</span><span class="p">)))</span>
            <span class="n">root_exp_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="n">exp_h</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;root_exp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_exp_ops</span>

    <span class="k">def</span> <span class="nf">_get_LC_hamil</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct the LC part of the circuit Hamiltonian.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The LC part of the Hamiltonian.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">LC_hamil</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># we write j in this form because of &quot;_memory_ops[&quot;QQ&quot;]&quot; shape</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                        <span class="n">LC_hamil</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                                     <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;QQ&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">LC_hamil</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">LC_hamil</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
                                     <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;QQ&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">LC_hamil</span>

    <span class="k">def</span> <span class="nf">_get_external_flux_at_element</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">B_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">torch</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the external flux at an inductive element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            B_idx:</span>
<span class="sd">                An integer point to each row of B matrix (external flux</span>
<span class="sd">                distribution of that element)</span>
<span class="sd">            torch:</span>
<span class="sd">                If ``True``, cast loop values to floats always</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The external flux at the element referenced by ``B_idx.``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi_ext</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">):</span>
            <span class="n">phi_ext</span> <span class="o">+=</span> <span class="n">loop</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">B_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">phi_ext</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">torch</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="n">phi_ext</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">phi_ext</span>

    <span class="k">def</span> <span class="nf">_get_inductive_hamil</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct the inductive part of the circuit Hamiltonian.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The inductive part of the Hamiltonian.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Inductor</span><span class="p">]:</span>
            <span class="c1"># phi = 0</span>
            <span class="c1"># if B_idx is not None:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_external_flux_at_element</span><span class="p">(</span><span class="n">B_idx</span><span class="p">)</span>

            <span class="c1"># summation of the 1 over inductor values.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">el</span><span class="o">.</span><span class="n">get_value</span><span class="p">()))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_op</span><span class="p">(</span><span class="s2">&quot;inductive&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">qutip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coupling_op</span><span class="p">(</span><span class="s2">&quot;inductive&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="p">),</span>
                <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_op_dims</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">H</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">*</span> <span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">op</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span><span class="p">)</span>

            <span class="c1"># save the operators for loss calculation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;ind_hamil&quot;</span><span class="p">][(</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">op</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Junction</span><span class="p">]:</span>
            <span class="c1"># phi = 0</span>
            <span class="c1"># if B_idx is not None:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_external_flux_at_element</span><span class="p">(</span><span class="n">B_idx</span><span class="p">)</span>

            <span class="n">EJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">get_value</span><span class="p">()))</span>

            <span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">][</span><span class="n">W_idx</span><span class="p">]</span>
            <span class="n">root_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;root_exp&quot;</span><span class="p">][</span>
                <span class="n">W_idx</span><span class="p">]</span>
            <span class="n">cos</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span> <span class="o">+</span> <span class="n">exp</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="n">exp</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="n">j</span>
            <span class="n">sin_half</span> <span class="o">=</span> <span class="p">(</span><span class="n">root_exp</span> <span class="o">-</span> <span class="n">root_exp</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="n">j</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;cos&quot;</span><span class="p">][</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">cos</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;sin&quot;</span><span class="p">][</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">sin</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;sin_half&quot;</span><span class="p">][</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">sin_half</span><span class="p">)</span>

            <span class="n">H</span> <span class="o">+=</span> <span class="o">-</span><span class="n">EJ</span> <span class="o">*</span> <span class="n">cos</span>

        <span class="k">return</span> <span class="n">H</span>

<div class="viewcode-block" id="Circuit.charge_op">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.charge_op">[docs]</a>
    <span class="k">def</span> <span class="nf">charge_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;FC&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return charge operator for specific mode in the Fock/Charge basis or</span>
<span class="sd">        the eigenbasis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mode:</span>
<span class="sd">                Integer that specifies the mode number.</span>
<span class="sd">            basis:</span>
<span class="sd">                String that specifies the basis. It can be either ``&#39;FC&#39;``</span>
<span class="sd">                for original Fock/Charge basis or ``&#39;eig&#39;`` for eigenbasis.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The charge operato for the ``i``th mode in the basis specified by</span>
<span class="sd">            ``basis``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">error1</span> <span class="o">=</span> <span class="s2">&quot;Please specify the truncation number for each mode.&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error1</span>

        <span class="c1"># charge operator in Fock/Charge basis</span>
        <span class="n">Q_FC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">][</span><span class="n">mode</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;FC&quot;</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">Q_FC</span>

        <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;eig&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>

                <span class="n">mat_evecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="o">.</span><span class="n">T</span>

                <span class="n">Q</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">qobj_to_tensor</span><span class="p">(</span><span class="n">Q_FC</span><span class="p">)</span>

                <span class="n">Q_eig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mat_evecs</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="n">Q</span> <span class="o">@</span> <span class="n">mat_evecs</span>

                <span class="k">return</span> <span class="n">Q_eig</span>

            <span class="n">mat_evecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">full</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">Q_eig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mat_evecs</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="n">Q_FC</span><span class="o">.</span><span class="n">full</span><span class="p">()</span> <span class="o">@</span> <span class="n">mat_evecs</span>

            <span class="k">return</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">Q_eig</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_W_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">el</span><span class="p">:</span> <span class="n">Junction</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">        Find the corresponding ``W`` matrix index given an junction and its</span>
<span class="sd">        ``B`` matrix index.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            el:</span>
<span class="sd">                Josephson junction in circuit.</span>
<span class="sd">            B_idx:</span>
<span class="sd">                Index of B matrix corresponding to ``el``.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The corresponding ``W`` matrix index, if it exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">o_el</span><span class="p">,</span> <span class="n">o_B_idx</span><span class="p">,</span> <span class="n">W_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Junction</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">o_el</span> <span class="o">==</span> <span class="n">el</span> <span class="ow">and</span> <span class="n">o_B_idx</span> <span class="o">==</span> <span class="n">B_idx</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">W_idx</span>

        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Circuit.op">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.op">[docs]</a>
    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">keywords</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Qobj</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a saved circuit operator of type ``typ``, specified by keywords</span>
<span class="sd">        given in the ``keywords`` dict, as a backpropagatable ``Tensor`` object </span>
<span class="sd">        when ``.get_optim_mode()`` is ``True``. Currently supports the</span>
<span class="sd">        following operators:</span>

<span class="sd">        * ``&#39;sin_half&#39;``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            typ:</span>
<span class="sd">                Type of saved operator.</span>
<span class="sd">            keywords:</span>
<span class="sd">                Dictionary specifying which operator of type ``typ`` to return.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            The `typ` operator of the circuit specified by ``keywords``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;sin_half&#39;</span><span class="p">:</span>
            <span class="n">B_idx</span> <span class="o">=</span> <span class="n">keywords</span><span class="p">[</span><span class="s1">&#39;B_idx&#39;</span><span class="p">]</span>
            <span class="n">el</span> <span class="o">=</span> <span class="n">keywords</span><span class="p">[</span><span class="s1">&#39;el&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>
                <span class="n">W_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_W_idx</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)</span>

                <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_external_flux_at_element</span><span class="p">(</span><span class="n">B_idx</span><span class="p">,</span> <span class="n">torch</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">root_exp</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">qobj_to_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;root_exp&quot;</span><span class="p">][</span><span class="n">W_idx</span><span class="p">])</span>
                <span class="p">)</span>

                <span class="n">sin_half</span> <span class="o">=</span> <span class="p">(</span><span class="n">root_exp</span> <span class="o">-</span> <span class="n">sqf</span><span class="o">.</span><span class="n">dag</span><span class="p">(</span><span class="n">root_exp</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="n">j</span>
                <span class="c1"># ToDo: need to squeeze?</span>
                <span class="k">return</span> <span class="n">sin_half</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;sin_half&#39;</span><span class="p">][</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


    <span class="k">def</span> <span class="nf">diag_np</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_eig</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Qobj</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform the diagonalization of the circuit Hailtonian using SciPy&#39;s</span>
<span class="sd">        sparse eigensolver. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            n_eig:</span>
<span class="sd">                Number of eigenvalues to compute.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            efreqs:</span>
<span class="sd">                Array of eigenfrequencies in frequency unit of SQcircuit.</span>
<span class="sd">            evecs:</span>
<span class="sd">                List of eigenvectors in qutip.Qobj or Tensor format, depending</span>
<span class="sd">                on optimization mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;Please specify the truncation number for each mode.&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_eig</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span>
            <span class="s2">&quot;n_eig (number of eigenvalues) should be an integer.&quot;</span>
        <span class="p">)</span>

        <span class="n">hamil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">()</span>

        <span class="c1"># get the data out of qutip variable and use sparse scipy eigen</span>
        <span class="c1"># solver which is faster.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">efreqs</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigs</span><span class="p">(</span>
                <span class="n">hamil</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">n_eig</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SR&#39;</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">ArpackNoConvergence</span><span class="p">:</span>
            <span class="n">efreqs</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigs</span><span class="p">(</span>
                <span class="n">hamil</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">n_eig</span><span class="p">,</span> <span class="n">ncv</span><span class="o">=</span><span class="mi">10</span><span class="o">*</span><span class="n">n_eig</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SR&#39;</span>
            <span class="p">)</span>
        <span class="c1"># the output of eigen solver is not sorted</span>
        <span class="n">efreqs_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">efreqs</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

        <span class="n">sort_arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">efreqs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sort_arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">sort_arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">sort_arg</span><span class="p">]</span>

        <span class="n">evecs_sorted</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">evecs</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_state_dims</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">sort_arg</span>
        <span class="p">]</span>

        <span class="c1"># store the eigenvalues and eigenvectors of the circuit Hamiltonian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span> <span class="o">=</span> <span class="n">efreqs_sorted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span> <span class="o">=</span> <span class="n">evecs_sorted</span>

        <span class="k">return</span> <span class="n">efreqs_sorted</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">()),</span> <span class="n">evecs_sorted</span>

    <span class="k">def</span> <span class="nf">_diag_torch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_eig</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Diagonalize the circuit using a Torch Function, so that the </span>
<span class="sd">        calculated eigenvalues/vectors are backpropagatable.</span>

<span class="sd">        To restrict the number ``n`` of eigenvectors for which the gradient is</span>
<span class="sd">        computed, call ``set_max_eigenvector_grad(n)`` before</span>
<span class="sd">        diagonalizing.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            n_eig:</span>
<span class="sd">                Number of eigenvalues to compute.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            efreqs:</span>
<span class="sd">                Tensor of eigenfrequencies.</span>
<span class="sd">            evecs:</span>
<span class="sd">                Tensor of eigenvectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eigen_solution</span> <span class="o">=</span> <span class="n">sqtorch</span><span class="o">.</span><span class="n">eigencircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_eig</span><span class="p">)</span>
        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eigen_solution</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">eigen_solution</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span> <span class="o">=</span> <span class="n">eigenvalues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span> <span class="o">=</span> <span class="n">eigenvectors</span>

        <span class="k">return</span> <span class="n">eigenvalues</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">()),</span> <span class="n">eigenvectors</span>

<div class="viewcode-block" id="Circuit.diag">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.diag">[docs]</a>
    <span class="k">def</span> <span class="nf">diag</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_eig</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Qobj</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Diagonalize the Hamiltonian of the circuit and return the</span>
<span class="sd">        eigenfrequencies and eigenvectors of the circuit up to specified</span>
<span class="sd">        number of eigenvalues.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            n_eig:</span>
<span class="sd">                Number of eigenvalues to output. The lower ``n_eig``, the</span>
<span class="sd">                faster ``SQcircuit`` finds the eigenvalues.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            efreqs:</span>
<span class="sd">                ndarray of eigenfrequencies in frequency unit of SQcircuit</span>
<span class="sd">                (gigahertz by default).</span>
<span class="sd">            evecs:</span>
<span class="sd">                List of eigenvectors in qutip.Qobj or Tensor format, depending</span>
<span class="sd">                on optimization mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;diag called&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag_torch</span><span class="p">(</span><span class="n">n_eig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">diag_np</span><span class="p">(</span><span class="n">n_eig</span><span class="p">)</span></div>


<div class="viewcode-block" id="Circuit.truncate_circuit">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.truncate_circuit">[docs]</a>
    <span class="k">def</span> <span class="nf">truncate_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">heuristic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set truncation numbers of circuit to ``k=ceil(K^{1/n})`` for all</span>
<span class="sd">        modes, where ``n`` is the number of modes in the circuit. If</span>
<span class="sd">        ``heuristic`` is true, then the truncation number for each harmonic</span>
<span class="sd">        mode is weighted by setting ``k_i = k * prod(omega_j^(1/n))/omega_i``</span>
<span class="sd">        All charge modes are left with truncation number ``K`` as above.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            K:</span>
<span class="sd">                Total truncation number</span>
<span class="sd">            heuristic:</span>
<span class="sd">                Whether to use a heurstic to set harmonic mode truncations </span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            trunc_nums:</span>
<span class="sd">                List of truncation numbers for each mode of circuit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trunc_num_average</span> <span class="o">=</span> <span class="n">K</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">heuristic</span><span class="p">:</span>
            <span class="n">harmonic_modes</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">harmonic_modes</span><span class="p">)</span> <span class="c1"># Number of harmonic modes</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">harmonic_modes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">A</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">f</span><span class="p">)</span>

            <span class="n">trunc_nums</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="c1"># charge mode</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">trunc_nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">trunc_num_average</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">trunc_num_average</span><span class="p">)</span> <span class="o">/</span> <span class="n">mode</span>
                    <span class="n">trunc_nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">h</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trunc_nums</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">trunc_num_average</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">))</span>
            <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_trunc_nums</span><span class="p">(</span><span class="n">trunc_nums</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trunc_nums</span></div>


<div class="viewcode-block" id="Circuit.check_convergence">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.check_convergence">[docs]</a>
    <span class="k">def</span> <span class="nf">check_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eig_vec_idx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the diagonalization of the circuit has converged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            eig_vec_idx:</span>
<span class="sd">                Index of eigenvector to use to test convergence.</span>
<span class="sd">            t:</span>
<span class="sd">                Number of entries of eigenvector to use to test convergence.</span>
<span class="sd">            threshold:</span>
<span class="sd">                Cutoff for convergence.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            convergence_succeeded:</span>
<span class="sd">                Truthy value of whether the circuit converged</span>
<span class="sd">            epsilon:</span>
<span class="sd">                Calculated value for convergence test</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;Must call circuit.diag before testing convergence&quot;</span>
        <span class="p">)</span>

        <span class="n">reshaped_evec</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evecs</span><span class="p">[</span><span class="n">eig_vec_idx</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
        <span class="n">restricted_evec</span> <span class="o">=</span> <span class="n">reshaped_evec</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">),)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)]</span>

        <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">restricted_evec</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">epsilon</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">),</span> <span class="n">epsilon</span></div>


    <span class="c1">###########################################################################</span>
    <span class="c1"># Methods that calculate circuit properties</span>
    <span class="c1">###########################################################################</span>

<div class="viewcode-block" id="Circuit.coord_transform">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.coord_transform">[docs]</a>
    <span class="k">def</span> <span class="nf">coord_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the transformation of the coordinates as ndarray for each type</span>
<span class="sd">        of variables, either charge or flux.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            var_type:</span>
<span class="sd">                The type of the variables that can be either ``&quot;charge&quot;`` or</span>
<span class="sd">                ``&quot;flux&quot;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Matrix giving coordinate transformation for ``var_type`` coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s2">&quot;charge&quot;</span> <span class="ow">or</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s2">&quot;Charge&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s2">&quot;flux&quot;</span> <span class="ow">or</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s2">&quot;Flux&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input must be either </span><span class="se">\&quot;</span><span class="s2">charge</span><span class="se">\&quot;</span><span class="s2"> or </span><span class="se">\&quot;</span><span class="s2">flux</span><span class="se">\&quot;</span><span class="s2">.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Circuit.hamiltonian">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.hamiltonian">[docs]</a>
    <span class="k">def</span> <span class="nf">hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the transformed hamiltonian of the circuit as</span>
<span class="sd">        ``qutip.Qobj`` format.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Circuit Hamiltonian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error</span> <span class="o">=</span> <span class="s2">&quot;Please specify the truncation number for each mode.&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error</span>

        <span class="n">Hind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_inductive_hamil</span><span class="p">()</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">Hind</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LC_hamil</span>

        <span class="k">return</span> <span class="n">H</span></div>


    <span class="k">def</span> <span class="nf">_tensor_to_modes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensorIndex</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decomposes the tensor product space index to each mode indices. For</span>
<span class="sd">        example index 5 of the tensor product space can be decomposed to [1,</span>
<span class="sd">        0,1] modes if the truncation number for each mode is 2.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            tensorIndex:</span>
<span class="sd">                Index of tensor product space</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            indList:</span>
<span class="sd">                A list of mode indices (self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># i-th mP element is the multiplication of the self.m elements until</span>
        <span class="c1"># its i-th element</span>
        <span class="n">mP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mP</span> <span class="o">=</span> <span class="p">[</span><span class="n">mP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">mP</span>

        <span class="n">indList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">indexP</span> <span class="o">=</span> <span class="n">tensorIndex</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indexP</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">indList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">indexP</span> <span class="o">/</span> <span class="n">mP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">indexP</span> <span class="o">=</span> <span class="n">indexP</span> <span class="o">%</span> <span class="n">mP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">indList</span>

<div class="viewcode-block" id="Circuit.eig_phase_coord">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.eig_phase_coord">[docs]</a>
    <span class="k">def</span> <span class="nf">eig_phase_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the phase coordinate representations of the eigenvectors as</span>
<span class="sd">        ndarray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            k:</span>
<span class="sd">                The eigenvector index. For example, we set it to 0 for the</span>
<span class="sd">                ground state and 1 for the first excited state.</span>
<span class="sd">            grid:</span>
<span class="sd">                A list that contains the range of values of phase φ for which</span>
<span class="sd">                we want to evaluate the wavefunction.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Phase coordinate representation of the ``k``th eigenvector over</span>
<span class="sd">            the values of φ provided in ``grid``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;The k (index of eigenstate) should be &quot;</span>
                                    <span class="s2">&quot;an integer.&quot;</span><span class="p">)</span>

        <span class="n">phi_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grid</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)]</span>

        <span class="c1"># The total dimension of the circuit Hilbert Space</span>
        <span class="n">netDimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>

        <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">netDimension</span><span class="p">):</span>

            <span class="c1"># decomposes the tensor product space index (i) to each mode</span>
            <span class="c1"># indices as a list</span>
            <span class="n">indList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_to_modes</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>
                <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>

                <span class="c1"># mode number related to that node</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">indList</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>

                <span class="c1"># For charge basis</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
                    <span class="n">term</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                        <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi_list</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
                <span class="c1"># For harmonic basis</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># compute in log-space due to large magnitude variation</span>
                    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">mode</span><span class="p">,</span> <span class="n">mode</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">mode</span><span class="p">,</span> <span class="n">mode</span><span class="p">]))</span>
                    
                    <span class="n">coeff_log</span> <span class="o">=</span> <span class="o">-</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> \
                                <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> \
                                <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> \
                                <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">250</span><span class="p">:</span>
                        <span class="n">term_hermitenorm</span> <span class="o">=</span> <span class="n">eval_hermitenorm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_list</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="n">x0</span><span class="p">)</span>
                        <span class="n">term_hermite_signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">term_hermitenorm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">term_hermitenorm</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">term_hermitenorm_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">term_hermitenorm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">term_hermitenorm</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">term_hyper</span> <span class="o">=</span> <span class="n">hyperu</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> 
                                            <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> 
                                            <span class="p">(</span><span class="n">phi_list</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">term_hermite_signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">term_hyper</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">phi_list</span><span class="p">[</span><span class="n">mode</span><span class="p">]),</span> <span class="n">n</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">term_hermitenorm_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">term_hyper</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">term_hyper</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># Resort to mpmath library if vectorized SciPy code fails</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">term_hermitenorm_log</span><span class="p">)):</span>
                        <span class="n">bad_pos</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">term_hermitenorm_log</span><span class="p">)</span>
                        <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">term_hermitenorm_log</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;multi_index&#39;</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
                            <span class="n">idx</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">multi_index</span>
                            <span class="k">if</span> <span class="n">bad_pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                                <span class="n">hermite_val</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">hermite</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">phi_list</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="n">x0</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">hermite_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">term_hermite_signs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                                    <span class="n">term_hermitenorm_log</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">term_hermite_signs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">hermite_val</span><span class="p">)</span>
                                    <span class="n">term_hermitenorm_log</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">hermite_val</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

                    <span class="n">term_log</span> <span class="o">=</span> <span class="n">coeff_log</span> \
                                <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">phi_list</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">*</span><span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span><span class="o">/</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> \
                                <span class="o">+</span> <span class="n">term_hermitenorm_log</span>

                    <span class="n">term</span> <span class="o">*=</span> <span class="n">term_hermite_signs</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">term_log</span><span class="p">)</span>

            <span class="n">state</span> <span class="o">+=</span> <span class="n">term</span>

        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1"># transposing the first two modes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indModes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
            <span class="n">indModes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">indModes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">indModes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">state</span></div>


<div class="viewcode-block" id="Circuit.coupling_op">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.coupling_op">[docs]</a>
    <span class="k">def</span> <span class="nf">coupling_op</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ctype</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the capacitive or inductive coupling operator related to the</span>
<span class="sd">        specified nodes. The output has the ``qutip.Qobj`` format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            ctype:</span>
<span class="sd">                Coupling type which is either ``&quot;capacitive&quot;`` or</span>
<span class="sd">                ``&quot;inductive&quot;``.</span>
<span class="sd">            nodes:</span>
<span class="sd">                A tuple of circuit nodes to which we want to couple.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Coupling operator of type ``ctype`` between nodes in ``nodes``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error1</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The coupling type must be either </span><span class="se">\&quot;</span><span class="s2">capacitive</span><span class="se">\&quot;</span><span class="s2"> or &quot;</span>
                  <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">inductive</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">ctype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;capacitive&quot;</span><span class="p">,</span> <span class="s2">&quot;inductive&quot;</span><span class="p">],</span> <span class="n">error1</span>
        <span class="n">error2</span> <span class="o">=</span> <span class="s2">&quot;Nodes must be a tuple of int&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="n">error2</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">init_sparse</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">node1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># for the case that we have ground in the edge</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node1</span> <span class="o">+</span> <span class="n">node2</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;capacitive&quot;</span><span class="p">:</span>
                <span class="c1"># K = np.linalg.inv(self.getMatC()) @ self.R</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">mat_mul</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">mat_inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">K</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;inductive&quot;</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">K</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;capacitive&quot;</span><span class="p">:</span>
                <span class="c1"># K = np.linalg.inv(self.getMatC()) @ self.R</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">mat_mul</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">mat_inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">node2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">K</span><span class="p">[</span><span class="n">node1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="o">*</span> \
                          <span class="n">sqf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;inductive&quot;</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="p">((</span><span class="n">K</span><span class="p">[</span><span class="n">node1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">K</span><span class="p">[</span><span class="n">node2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                           <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span></div>


<div class="viewcode-block" id="Circuit.matrix_elements">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.matrix_elements">[docs]</a>
    <span class="k">def</span> <span class="nf">matrix_elements</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ctype</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the matrix element of two eigenstates for either capacitive</span>
<span class="sd">        or inductive coupling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            ctype:</span>
<span class="sd">                Coupling type which is either ``&quot;capacitive&quot;`` or</span>
<span class="sd">                ``&quot;inductive&quot;``.</span>
<span class="sd">            nodes:</span>
<span class="sd">                A tuple of circuit nodes to which we want to couple.</span>
<span class="sd">            states:</span>
<span class="sd">                A tuple of indices of eigenstates for which we want to</span>
<span class="sd">                calculate the matrix element.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Matrix element between eigenstates in ``states`` for coupling</span>
<span class="sd">            operator of type ``ctype`` between nodes in ``nodes``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">state1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">state2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># get the coupling operator</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_op</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

        <span class="c1"># return (state1.dag() * op * state2).data[0, 0] (original)</span>
        <span class="k">return</span> <span class="n">sqf</span><span class="o">.</span><span class="n">operator_inner_product</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">state2</span><span class="p">)</span> <span class="c1"># (modified)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_dephasing</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">partial_omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate a dephasing rate of arbitrary type given a noise amplitude</span>
<span class="sd">        and eigenfrequency derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            A:</span>
<span class="sd">                Noise Amplitude</span>
<span class="sd">            partial_omega:</span>
<span class="sd">                The derivatives of angular frequency with respect to the</span>
<span class="sd">                noisy parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Dephasing rate specified by ``A`` and ``partial_omega``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">partial_omega</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;omega_low&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;t_exp&quot;</span><span class="p">]))))</span>

    <span class="k">def</span> <span class="nf">_dec_rate_flux_np</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate dephasing rate due to flux noise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            states:</span>
<span class="sd">                A tuple of state to calculate the decoherence rate</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Flux dephasing rate between ``states``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">decay</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
            <span class="n">partial_omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_partial_omega_mn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="n">states</span><span class="p">)</span>
            <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dephasing</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">partial_omega</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">decay</span>

    <span class="k">def</span> <span class="nf">_dec_rate_charge_np</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate dephasing rate due to charge noise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            states:</span>
<span class="sd">                A tuple of state to calculate the decoherence rate</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Charge dephasing rate between ``states``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state_m</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">state_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">decay</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_charge_mode</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span><span class="p">))</span>

                <span class="n">partial_omega</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">operator_inner_product</span><span class="p">(</span><span class="n">state_m</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">state_m</span><span class="p">)</span>
                                        <span class="o">-</span> <span class="n">sqf</span><span class="o">.</span><span class="n">operator_inner_product</span><span class="p">(</span><span class="n">state_n</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">state_n</span><span class="p">))</span>
                <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">e</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dephasing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">partial_omega</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">decay</span>

    <span class="k">def</span> <span class="nf">_dec_rate_cc_np</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate dephasing rate due to critical current noise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            states:</span>
<span class="sd">                A tuple of state to calculate the decoherence rate</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Critical current dephasing rate between ``states``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">decay</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">]:</span>
            <span class="n">partial_omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_partial_omega_mn</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="n">states</span><span class="p">,</span> <span class="n">_B_idx</span><span class="o">=</span><span class="n">B_idx</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="n">el</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
            <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dephasing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">partial_omega</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">decay</span>

<div class="viewcode-block" id="Circuit.dec_rate">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.dec_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">dec_rate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dec_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">total</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the decoherence rate in [1/s] between each two eigenstates</span>
<span class="sd">        for different types of depolarization and dephasing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            dec_type:</span>
<span class="sd">                decoherence type that can be: ``&quot;capacitive&quot;`` for capacitive</span>
<span class="sd">                loss; ``&quot;inductive&quot;`` for inductive loss; `&quot;quasiparticle&quot;` for</span>
<span class="sd">                quasiparticle loss; ``&quot;charge&quot;`` for charge noise, ``&quot;flux&quot;``</span>
<span class="sd">                for flux noise; and ``&quot;cc&quot;`` for critical current noise.</span>
<span class="sd">            states:</span>
<span class="sd">                A tuple of eigenstate indices, for which we want to</span>
<span class="sd">                calculate the decoherence rate. For example, for ``states=(0,</span>
<span class="sd">                1)``, we calculate the decoherence rate between the ground</span>
<span class="sd">                state and the first excited state.</span>
<span class="sd">            total:</span>
<span class="sd">                if False return a decoherence rate associated with a</span>
<span class="sd">                transition from state m to state n for ``states=(m, n)``. if</span>
<span class="sd">                True return a decoherence rate associated with both m to n</span>
<span class="sd">                and n to m transitions.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Decoherence/dephasing rate between ``states`` specified by </span>
<span class="sd">            ``dec_type``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">omega1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">omega2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">state1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">state2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">omega2</span> <span class="o">-</span> <span class="n">omega1</span><span class="p">)</span>

        <span class="n">decay</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># prevent the exponential overflow(exp(709) is the biggest number</span>
        <span class="c1"># that numpy can calculate</span>
        <span class="k">if</span> <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">/</span> <span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">k_B</span> <span class="o">*</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">709</span><span class="p">:</span>
            <span class="n">down</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">up</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">/</span> <span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">k_B</span> <span class="o">*</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span>
            <span class="n">down</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sqf</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">up</span> <span class="o">=</span> <span class="n">down</span> <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span>

        <span class="c1"># for temperature dependent loss</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">total</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">tempS</span> <span class="o">=</span> <span class="n">down</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tempS</span> <span class="o">=</span> <span class="n">up</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tempS</span> <span class="o">=</span> <span class="n">down</span> <span class="o">+</span> <span class="n">up</span>

        <span class="k">if</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;capacitive&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">edge</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Capacitor</span><span class="p">):</span>
                        <span class="n">cap</span> <span class="o">=</span> <span class="n">el</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cap</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">cap</span>
                    <span class="k">if</span> <span class="n">cap</span><span class="o">.</span><span class="n">Q</span><span class="p">:</span>
                        <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="n">tempS</span> <span class="o">*</span> <span class="n">cap</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span> <span class="o">/</span> <span class="n">cap</span><span class="o">.</span><span class="n">Q</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">matrix_elements</span><span class="p">(</span>
                                <span class="s2">&quot;capacitive&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">states</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;inductive&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;ind_hamil&quot;</span><span class="p">]:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;ind_hamil&quot;</span><span class="p">][(</span><span class="n">el</span><span class="p">,</span> <span class="n">_</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">Q</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">Q</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])):</span>
                        <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="n">tempS</span> <span class="o">/</span> <span class="n">el</span><span class="o">.</span><span class="n">Q</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">el</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span> <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                            <span class="n">sqf</span><span class="o">.</span><span class="n">operator_inner_product</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">state2</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;quasiparticle&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;sin_half&#39;</span><span class="p">]:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s1">&#39;sin_half&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;el&#39;</span><span class="p">:</span> <span class="n">el</span><span class="p">,</span> <span class="s1">&#39;B_idx&#39;</span><span class="p">:</span> <span class="n">B_idx</span><span class="p">})</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]))):</span>
                    <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="n">tempS</span> <span class="o">*</span> <span class="n">el</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">el</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span> \
                        <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                        <span class="n">sqf</span><span class="o">.</span><span class="n">operator_inner_product</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">state2</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">elif</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;charge&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="n">sqtorch</span><span class="o">.</span><span class="n">dec_rate_charge_torch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dec_rate_charge_np</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;cc&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="n">sqtorch</span><span class="o">.</span><span class="n">dec_rate_cc_torch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dec_rate_cc_np</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;flux&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">get_optim_mode</span><span class="p">():</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="n">sqtorch</span><span class="o">.</span><span class="n">dec_rate_flux_torch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dec_rate_flux_np</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">decay</span></div>


    <span class="k">def</span> <span class="nf">_get_quadratic_Q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return quadratic form of 1/2 * Q^T * A * Q</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            A:</span>
<span class="sd">                ndarray matrix that specifies the coefficient for</span>
<span class="sd">                quadratic expression.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Quadratic form with charge operators using ``A``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;QQ&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;QQ&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">op</span>

    <span class="k">def</span> <span class="nf">_get_quadratic_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get quadratic form of 1/2 * phi^T * A * phi</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            A:</span>
<span class="sd">                ndarray matrix that specifies the coefficient for</span>
<span class="sd">                quadratic expression.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Quadratic form with flux operators using ``A``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="c1"># number of harmonic modes</span>
        <span class="n">n_H</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_H</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_H</span><span class="p">):</span>
                <span class="n">phi_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">phi_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">phi_i</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">phi_i</span> <span class="o">*</span> <span class="n">phi_j</span>

        <span class="k">return</span> <span class="n">op</span>

    <span class="k">def</span> <span class="nf">_get_partial_H</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">el</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Capacitor</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">,</span> <span class="n">Junction</span><span class="p">,</span> <span class="n">Loop</span><span class="p">],</span>
        <span class="n">_B_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the gradient of the Hamiltonian with respect to elements or</span>
<span class="sd">        loop as ``qutip.Qobj`` format.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            el:</span>
<span class="sd">                Element of a circuit that can be either ``Capacitor``,</span>
<span class="sd">                ``Inductor``, ``Junction``, or ``Loop``.</span>
<span class="sd">            _B_idx:</span>
<span class="sd">                Optional integer to indicate which row of the B matrix</span>
<span class="sd">                (per-element external flux distribution) to use. This specifies</span>
<span class="sd">                which JJ of the circuit to consider specifically (ex. for</span>
<span class="sd">                critical current noise calculation).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Partial derivative of Hamiltonian with respect to ``el``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">partial_H</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Capacitor</span><span class="p">):</span>
            <span class="n">cInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">cInv</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_mats</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">@</span> <span class="n">cInv</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span>
            <span class="n">partial_H</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_quadratic_Q</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">):</span>

            <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_mats</span><span class="p">[</span><span class="n">el</span><span class="p">]</span>  <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
            <span class="n">partial_H</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_quadratic_phi</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Inductor</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="n">el_ind</span><span class="p">:</span>

                    <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_external_flux_at_element</span><span class="p">(</span><span class="n">B_idx</span><span class="p">)</span>

                    <span class="n">partial_H</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;ind_hamil&quot;</span><span class="p">][(</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)]</span>
                                   <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">get_value</span><span class="p">()))</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span><span class="p">)</span>
                                   <span class="o">*</span> <span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Loop</span><span class="p">):</span>

            <span class="n">loop_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Inductor</span><span class="p">]:</span>
                <span class="n">partial_H</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">B_idx</span><span class="p">,</span> <span class="n">loop_idx</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;ind_hamil&quot;</span><span class="p">][(</span><span class="n">el_ind</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)]</span>
                    <span class="o">/</span> <span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="n">el_ind</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                    <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">el_JJ</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Junction</span><span class="p">]:</span>
                <span class="n">partial_H</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">B_idx</span><span class="p">,</span> <span class="n">loop_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="n">el_JJ</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                              <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;sin&#39;</span><span class="p">][(</span><span class="n">el_JJ</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)])</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Junction</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">el_JJ</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_keys</span><span class="p">[</span><span class="n">Junction</span><span class="p">]:</span>

                <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="n">el_JJ</span> <span class="ow">and</span> <span class="n">_B_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">partial_H</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">][(</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)]</span>

                <span class="k">elif</span> <span class="n">el</span> <span class="o">==</span> <span class="n">el_JJ</span> <span class="ow">and</span> <span class="n">_B_idx</span> <span class="o">==</span> <span class="n">B_idx</span><span class="p">:</span>
                    <span class="n">partial_H</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">][(</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">partial_H</span>

<div class="viewcode-block" id="Circuit.get_partial_omega">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.get_partial_omega">[docs]</a>
    <span class="k">def</span> <span class="nf">get_partial_omega</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">el</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Capacitor</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">,</span> <span class="n">Junction</span><span class="p">,</span> <span class="n">Loop</span><span class="p">],</span>
        <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">subtract_ground</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">_B_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the gradient of the eigen angular frequency with respect to</span>
<span class="sd">        elements or loop as ``qutip.Qobj`` format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            el:</span>
<span class="sd">                Element of a circuit that can be either ``Capacitor``,</span>
<span class="sd">                ``Inductor``, ``Junction``, or ``Loop``.</span>
<span class="sd">            m:</span>
<span class="sd">                Integer specifies the eigenvalue. for example ``m=0`` specifies</span>
<span class="sd">                the ground state and ``m=1`` specifies the first excited state.</span>
<span class="sd">            subtract_ground:</span>
<span class="sd">                If ``True``, it subtracts the ground state frequency from the</span>
<span class="sd">                desired frequency.</span>
<span class="sd">            _B_idx:</span>
<span class="sd">                Optional integer to indicate which row of the B matrix</span>
<span class="sd">                (per-element external flux distribution) to use. This specifies</span>
<span class="sd">                which JJ of the circuit to consider specifically (ex. for</span>
<span class="sd">                critical current noise calculation).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Partial derivative of eigenfrequency ``m`` with respect to ``el``,</span>
<span class="sd">            in units of angular frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">state_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">partial_H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_partial_H</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">_B_idx</span><span class="p">)</span>
        <span class="n">partial_omega_m</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">operator_inner_product</span><span class="p">(</span>
            <span class="n">state_m</span><span class="p">,</span> <span class="n">partial_H</span><span class="p">,</span> <span class="n">state_m</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">subtract_ground</span><span class="p">:</span>
            <span class="n">state_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">partial_omega_0</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">operator_inner_product</span><span class="p">(</span>
                <span class="n">state_0</span><span class="p">,</span> <span class="n">partial_H</span><span class="p">,</span> <span class="n">state_0</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">sqf</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">partial_omega_m</span> <span class="o">-</span> <span class="n">partial_omega_0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sqf</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">partial_omega_m</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_partial_omega_mn</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">el</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Capacitor</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">,</span> <span class="n">Junction</span><span class="p">,</span> <span class="n">Loop</span><span class="p">],</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">_B_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the gradient of the eigen angular frequency with respect to</span>
<span class="sd">        elements or loop as ``qutip.Qobj`` format. Note that if</span>
<span class="sd">        ``states=(m, n)``, it returns ``partial_omega_m - partial_omega_n``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            el:</span>
<span class="sd">                Element of a circuit that can be either ``Capacitor``,</span>
<span class="sd">                ``Inductor``, ``Junction``, or ``Loop``.</span>
<span class="sd">            states:</span>
<span class="sd">                Integers indicating indices of eigenenergies to calculate</span>
<span class="sd">                the difference of.</span>
<span class="sd">            _B_idx:</span>
<span class="sd">                Optional integer to indicate which row of the B matrix (external</span>
<span class="sd">                flux distribution of that element) to use. This specifies which</span>
<span class="sd">                JJ of the circuit to consider specifically (ex. for critical</span>
<span class="sd">                current noise calculation).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Partial derivative of the energy difference between ``states``</span>
<span class="sd">            with respect to ``el``, in units of angular frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">state_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">state_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">partial_H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_partial_H</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">_B_idx</span><span class="p">)</span>

        <span class="n">partial_omega_m</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">operator_inner_product</span><span class="p">(</span>
            <span class="n">state_m</span><span class="p">,</span> <span class="n">partial_H</span><span class="p">,</span> <span class="n">state_m</span>
        <span class="p">)</span>
        <span class="n">partial_omega_n</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">operator_inner_product</span><span class="p">(</span>
            <span class="n">state_n</span><span class="p">,</span> <span class="n">partial_H</span><span class="p">,</span> <span class="n">state_n</span>
        <span class="p">)</span>

        <span class="n">partial_omega_mn</span> <span class="o">=</span> <span class="n">partial_omega_m</span> <span class="o">-</span> <span class="n">partial_omega_n</span>
        <span class="c1"># assert sqf.imag(partial_omega_mn)/sqf.real(partial_omega_mn) &lt; 1e-6</span>

        <span class="k">return</span> <span class="n">sqf</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">partial_omega_mn</span><span class="p">)</span>

<div class="viewcode-block" id="Circuit.get_partial_vec">
<a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.get_partial_vec">[docs]</a>
    <span class="k">def</span> <span class="nf">get_partial_vec</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">el</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Element</span><span class="p">,</span> <span class="n">Loop</span><span class="p">],</span>
        <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-12</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the gradient of the eigenvectors with respect to</span>
<span class="sd">        elements or loop as ``qutip.Qobj`` format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            el:</span>
<span class="sd">                Element of a circuit that can be either ``Capacitor``,</span>
<span class="sd">                ``Inductor``, ``Junction``, or ``Loop``.</span>
<span class="sd">            m:</span>
<span class="sd">                Integer specifies the eigenvalue. for example ``m=0`` specifies</span>
<span class="sd">                the ground state and ``m=1`` specifies the first excited state.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            Partial derivative of the ``m``th eigenvector, with respect to</span>
<span class="sd">            ``el``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">state_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>

        <span class="n">n_eig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">)</span>

        <span class="n">partial_H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_partial_H</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
        <span class="n">partial_state</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">state_m</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_eig</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">state_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

            <span class="n">delta_omega</span> <span class="o">=</span> <span class="n">sqf</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delta_omega</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
                <span class="n">delta_omega</span> <span class="o">=</span> <span class="n">delta_omega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">partial_state</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">sqf</span><span class="o">.</span><span class="n">operator_inner_product</span><span class="p">(</span><span class="n">state_n</span><span class="p">,</span> <span class="n">partial_H</span><span class="p">,</span> <span class="n">state_m</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">state_n</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">delta_omega</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">partial_state</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Taha Rajabzadeh, Amir Safavi-Naeini.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>