<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SQcircuit.circuit &mdash; SQcircuit 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> SQcircuit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quick_tutorial.html">Quick Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/guides.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html#contributors">Contributors</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SQcircuit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>SQcircuit.circuit</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for SQcircuit.circuit</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">circuit.py contains the classes for the circuit and their properties</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="k">as</span> <span class="nn">qt</span>
<span class="kn">import</span> <span class="nn">scipy.special</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span> <span class="nn">qutip.qobj</span> <span class="kn">import</span> <span class="n">Qobj</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">sqrtm</span><span class="p">,</span> <span class="n">block_diag</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">eval_hermite</span>

<span class="kn">import</span> <span class="nn">SQcircuit.units</span> <span class="k">as</span> <span class="nn">unt</span>

<span class="kn">from</span> <span class="nn">SQcircuit.elements</span> <span class="kn">import</span> <span class="n">Capacitor</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">,</span> <span class="n">Junction</span><span class="p">,</span> <span class="n">Loop</span><span class="p">,</span> <span class="n">Charge</span>
<span class="kn">from</span> <span class="nn">SQcircuit.texts</span> <span class="kn">import</span> <span class="n">is_notebook</span><span class="p">,</span> <span class="n">HamilTxt</span>
<span class="kn">from</span> <span class="nn">SQcircuit.noise</span> <span class="kn">import</span> <span class="n">ENV</span>


<div class="viewcode-block" id="Circuit"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit">[docs]</a><span class="k">class</span> <span class="nc">Circuit</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that contains the circuit properties and uses the theory discussed</span>
<span class="sd">    in the original paper of the SQcircuit to calculate:</span>

<span class="sd">        * Eigenvalues and eigenvectors</span>
<span class="sd">        * Phase coordinate representation of eigenvectors</span>
<span class="sd">        * Coupling operators</span>
<span class="sd">        * Matrix elements</span>
<span class="sd">        * Decoherence rates</span>
<span class="sd">        * Robustness analysis</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        elements:</span>
<span class="sd">            A dictionary that contains the circuit&#39;s elements at each branch</span>
<span class="sd">            of the circuit.</span>
<span class="sd">        random:</span>
<span class="sd">            If `True`, each element of the circuit is a random number due to</span>
<span class="sd">            fabrication error. This is necessary for robustness analysis.</span>
<span class="sd">        flux_dist:</span>
<span class="sd">            Provide the method of distributing the external fluxes. If</span>
<span class="sd">            ``flux_dist`` is ``&quot;all&quot;``, SQcircuit assign the external fluxes</span>
<span class="sd">            based on the capacitor of each inductive element (This option is</span>
<span class="sd">            necessary for time-dependent external fluxes). If ``flux_dist`` is</span>
<span class="sd">            ``&quot;inductor&quot;`` SQcircuit finds the external flux distribution by</span>
<span class="sd">            assuming the capacitor of the inductors are much smaller than the</span>
<span class="sd">            junction capacitors, If ``flux_dist`` is ``&quot;junction&quot;`` it is the</span>
<span class="sd">            other way around.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">elements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                           <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Capacitor</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">,</span> <span class="n">Junction</span><span class="p">]]],</span>
            <span class="n">flux_dist</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;junctions&#39;</span><span class="p">,</span>
            <span class="n">random</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1">#######################################################################</span>
        <span class="c1"># General circuit attributes</span>
        <span class="c1">#######################################################################</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">elements</span>

        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;flux_dist option must be either </span><span class="se">\&quot;</span><span class="s2">junctions</span><span class="se">\&quot;</span><span class="s2">, &quot;</span>
                 <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">inductors</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">all</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">flux_dist</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;junctions&quot;</span><span class="p">,</span> <span class="s2">&quot;inductors&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_dist</span> <span class="o">=</span> <span class="n">flux_dist</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="n">random</span>

        <span class="c1"># circuit inductive loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Loop</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># charge islands of the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Charge</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># number of nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">))</span>

        <span class="c1"># number of branches that contain JJ without parallel inductor.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># inductor element keys: (edge, el, B_idx) B_idx point to</span>
        <span class="c1"># each row of B matrix (external flux distribution of that element)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inductor_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># junction element keys: (edge, el, B_idx, W_idx) B_idx point to</span>
        <span class="c1"># each row of B matrix (external flux distribution of that element)</span>
        <span class="c1"># and W_idx point to each row of W matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">junction_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Junction</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#######################################################################</span>
        <span class="c1"># Transformation related attributes</span>
        <span class="c1">#######################################################################</span>

        <span class="c1"># get the capacitance matrix, sudo-inductance matrix, W matrix,</span>
        <span class="c1"># and B matrix (loop distribution over inductive elements)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_LCWB</span><span class="p">()</span>

        <span class="c1"># the inverse of transformation of coordinates for charge operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="c1"># the inverse of transformation of coordinates for flux operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="c1"># S and R matrix of first, second, and third transformation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="c1"># transformed sudo-inductance matrix (diagonal matrix)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="c1"># transformed capacitance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cTrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="c1"># transformed inverse capacitance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="c1"># transformed W matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span>

        <span class="c1"># natural angular frequencies of the circuit for each mode as a numpy</span>
        <span class="c1"># array (zero for charge modes)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># transform the Hamiltonian of the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform_hamil</span><span class="p">()</span>

        <span class="c1">#######################################################################</span>
        <span class="c1"># Operator and diagonalization related attributes</span>
        <span class="c1">#######################################################################</span>

        <span class="c1"># truncation numbers for each mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># squeezed truncation numbers (eliminating the modes with truncation</span>
        <span class="c1"># number equals 1)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">],</span>
                                          <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># list of identity operators</span>
            <span class="s2">&quot;Q&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># list of charge operators (normalized by 1/sqrt(hbar))</span>
            <span class="s2">&quot;QQ&quot;</span><span class="p">:</span> <span class="p">[[]],</span>  <span class="c1"># list of charge times charge operators</span>
            <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># list of flux operators (normalized by 1/sqrt(hbar))</span>
            <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># list of number operators</span>
            <span class="s2">&quot;exp&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># List of exponential operators</span>
            <span class="s2">&quot;root_exp&quot;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># List of square root of exponential operators</span>
            <span class="s2">&quot;cos&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># List of cosine operators</span>
            <span class="s2">&quot;sin&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># List of sine operators</span>
            <span class="s2">&quot;sin_half&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># list of sin(phi/2)</span>
            <span class="s2">&quot;ind_hamil&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># list of w^T*phi that appears in Hamiltonian</span>
        <span class="p">}</span>

        <span class="c1"># LC part of the Hamiltonian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LC_hamil</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="c1"># eigenvalues of the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="c1"># eigenvectors of the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="c1"># type_attrs = type(self).__dict__</span>

        <span class="c1"># Attributes that we are avoiding to store for reducing the size of</span>
        <span class="c1"># the saved file( Qutip objects and Quantum operators usually).</span>
        <span class="n">avoid_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_memory_ops&quot;</span><span class="p">,</span> <span class="s2">&quot;_LC_hamil&quot;</span><span class="p">]</span>

        <span class="n">self_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">avoid_attrs</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">self_dict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">state</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_independentRows</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;use Gram–Schmidt to find the linear independent rows of matrix A</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># normalize the row of matrix A</span>
        <span class="n">A_norm</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">idx_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_norm</span><span class="p">):</span>
            <span class="n">a_prime</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="o">*</span> <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a_prime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">idx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_prime</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a_prime</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">idx_list</span><span class="p">,</span> <span class="n">basis</span>

    <span class="k">def</span> <span class="nf">_add_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">:</span> <span class="n">Loop</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add loop to the circuit loops.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">loop</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_LCWB</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculate the capacitance matrix, inductance matrix, W matrix,</span>
<span class="sd">        and the flux distribution over inductive elements B.</span>
<span class="sd">        outputs:</span>
<span class="sd">            -- cMat: capacitance matrix (self.n,self.n)</span>
<span class="sd">            -- lMat: inductance matrix (self.n,self.n)</span>
<span class="sd">            -- wMat:  W matrix(linear combination of the flux node operators</span>
<span class="sd">            in the JJ cosine (n_J,self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="n">lMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="n">wMat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># point to each row of B matrix (external flux distribution of that</span>
        <span class="c1"># element) or count the number of inductive elements.</span>
        <span class="n">B_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># W_idx point to each row of W matrix for junctions or count the</span>
        <span class="c1"># number of edges contain JJ</span>
        <span class="n">W_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># number of branches that contain JJ without parallel inductor.</span>
        <span class="n">countJJnoInd</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># K1 is a matrix that transfer node coordinates to edge phase drop</span>
        <span class="c1"># for inductive elements</span>
        <span class="n">K1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># capacitor at each inductive elements</span>
        <span class="n">cEd</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># i1 and i2 are the nodes of the edge</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">edge</span>

            <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">i1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">w</span><span class="p">[</span><span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">w</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="c1"># elements of the edge</span>
            <span class="n">edgeElements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>

            <span class="c1"># list of capacitors of the edge.</span>
            <span class="n">capList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># list of inductors of the edge</span>
            <span class="n">indList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># list of Josephson Junction of the edge.</span>
            <span class="n">JJList</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">edgeElements</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Capacitor</span><span class="p">):</span>
                    <span class="n">capList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">):</span>
                    <span class="c1"># if el.loops:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inductor_keys</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">))</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     self.inductor_keys.append((edge, el, None))</span>
                    <span class="n">indList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                    <span class="c1"># capacitor of inductor</span>
                    <span class="n">capList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="p">)</span>
                    <span class="n">loops</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">loops</span>
                    <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">loops</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
                        <span class="n">loop</span><span class="o">.</span><span class="n">add_index</span><span class="p">(</span><span class="n">B_idx</span><span class="p">)</span>
                        <span class="n">loop</span><span class="o">.</span><span class="n">addK1</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="n">B_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">K1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_dist</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_dist</span> <span class="o">==</span> <span class="s2">&quot;junctions&quot;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Capacitor</span><span class="p">(</span><span class="mf">1e20</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_dist</span> <span class="o">==</span> <span class="s2">&quot;inductors&quot;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Capacitor</span><span class="p">(</span><span class="mf">1e-20</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Junction</span><span class="p">):</span>
                    <span class="c1"># if el.loops:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">junction_keys</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span><span class="p">))</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     self.junction_keys.append((edge, el, None, W_idx))</span>
                    <span class="n">JJList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                    <span class="c1"># capacitor of JJ</span>
                    <span class="n">capList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="p">)</span>
                    <span class="n">loops</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">loops</span>
                    <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">loops</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
                        <span class="n">loop</span><span class="o">.</span><span class="n">add_index</span><span class="p">(</span><span class="n">B_idx</span><span class="p">)</span>
                        <span class="n">loop</span><span class="o">.</span><span class="n">addK1</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="n">B_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">K1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_dist</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_dist</span> <span class="o">==</span> <span class="s2">&quot;junctions&quot;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Capacitor</span><span class="p">(</span><span class="mf">1e-20</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_dist</span> <span class="o">==</span> <span class="s2">&quot;inductors&quot;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Capacitor</span><span class="p">(</span><span class="mf">1e20</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">JJList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">countJJnoInd</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># summation of the capacitor values.</span>
            <span class="n">cap</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">),</span> <span class="n">capList</span><span class="p">)))</span>

            <span class="c1"># summation of the one over inductor values.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">),</span>
                                             <span class="n">indList</span><span class="p">))))</span>

            <span class="k">if</span> <span class="n">i1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cap</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="k">elif</span> <span class="n">i1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cap</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">cap</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">cap</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cap</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cap</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">JJList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">wMat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">W_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">wMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wMat</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">K1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">K1</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">K1</span><span class="p">)</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K1</span> <span class="o">!=</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="c1"># eliminate the zero columns</span>
            <span class="n">K1</span> <span class="o">=</span> <span class="n">K1</span><span class="p">[:,</span> <span class="n">select</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">K1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">K1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">K1</span> <span class="o">=</span> <span class="n">K1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">X</span> <span class="o">=</span> <span class="n">K1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cEd</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">))</span>
                <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">loop</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">getP</span><span class="p">()</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># number of inductive loops of the circuit</span>
            <span class="n">n_loops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_loops</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">B_idx</span> <span class="o">-</span> <span class="n">n_loops</span><span class="p">,</span> <span class="n">n_loops</span><span class="p">)),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_loops</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">bMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">@</span> <span class="n">Y</span>
                <span class="n">bMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">bMat</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The edge list does not specify a connected graph or &quot;</span>
                  <span class="s2">&quot;all inductive loops of the circuit are not specified.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span> <span class="o">=</span> <span class="n">countJJnoInd</span>

        <span class="k">return</span> <span class="n">cMat</span><span class="p">,</span> <span class="n">lMat</span><span class="p">,</span> <span class="n">wMat</span><span class="p">,</span> <span class="n">bMat</span>

    <span class="k">def</span> <span class="nf">_transform1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First transformation of the coordinates that simultaneously diagonalizes</span>
<span class="sd">        the capacitance and inductance matrices.</span>

<span class="sd">        output:</span>
<span class="sd">            --  lTrans: diagonalized sudo-inductance matrix (self.n,self.n)</span>
<span class="sd">            --  cInvTrans: diagonalized inverse of capacitance</span>
<span class="sd">                matrix (self.n,self.n)</span>
<span class="sd">            --  R1: transformation of charge operators (self.n,self.n)</span>
<span class="sd">            --  S1: transformation of flux operators (self.n,self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># cMat = self.getMatC()</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span>
        <span class="c1"># lMat = self.getMatL()</span>
        <span class="n">lMat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="n">cMatInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cMat</span><span class="p">)</span>

        <span class="n">cMatRoot</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">cMat</span><span class="p">)</span>
        <span class="n">cMatRootInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cMatRoot</span><span class="p">)</span>
        <span class="n">lMatRoot</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">lMat</span><span class="p">)</span>

        <span class="n">V</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">lMatRoot</span> <span class="o">@</span> <span class="n">cMatRootInv</span><span class="p">)</span>

        <span class="c1"># the case that there is not any inductor in the circuit</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
            <span class="n">singLoc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># find the number of singularity in the circuit</span>
            <span class="n">lEig</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">lMat</span><span class="p">)</span>
            <span class="n">numSing</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lEig</span><span class="p">[</span><span class="n">lEig</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lEig</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-11</span><span class="p">])</span>
            <span class="n">singLoc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">numSing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
            <span class="n">D</span><span class="p">[</span><span class="n">singLoc</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

        <span class="c1"># build S1 and R1 matrix</span>
        <span class="n">S1</span> <span class="o">=</span> <span class="n">cMatRootInv</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
        <span class="n">R1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">cInvTrans</span> <span class="o">=</span> <span class="n">R1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">cMatInv</span> <span class="o">@</span> <span class="n">R1</span>
        <span class="n">lTrans</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">lMat</span> <span class="o">@</span> <span class="n">S1</span>

        <span class="n">lTrans</span><span class="p">[</span><span class="n">singLoc</span><span class="p">,</span> <span class="n">singLoc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">lTrans</span><span class="p">,</span> <span class="n">cInvTrans</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span> <span class="n">R1</span>

    <span class="k">def</span> <span class="nf">_transform2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">S1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Second transformation of the coordinates that transforms the subspace</span>
<span class="sd">        of the charge operators which are defined in the charge basis in</span>
<span class="sd">        order to have the Bloch wave vectors in the cartesian direction.</span>
<span class="sd">        output:</span>
<span class="sd">            --  R2: Second transformation of charge operators (self.n,self.n)</span>
<span class="sd">            --  S2: Second transformation of flux operators (self.n,self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># apply the first transformation on w and get the charge basis part</span>
        <span class="n">wTrans1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">@</span> <span class="n">S1</span>
        <span class="n">wQ</span> <span class="o">=</span> <span class="n">wTrans1</span><span class="p">[:,</span> <span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># number of operators represented in charge bases</span>
        <span class="n">nq</span> <span class="o">=</span> <span class="n">wQ</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># if we need to represent an operator in charge basis</span>
        <span class="k">if</span> <span class="n">nq</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># list of indices of w vectors that are independent</span>
            <span class="n">indList</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># use Gram–Schmidt to find the linear independent rows of</span>
            <span class="c1"># normalized wQ (wQ_norm)</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nq</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">indList</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_independentRows</span><span class="p">(</span><span class="n">wQ</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># to complete the basis</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nq</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">),</span> <span class="n">nq</span><span class="p">))</span>
                    <span class="n">basisComplete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">basis</span> <span class="o">+</span> <span class="n">X</span><span class="p">)</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_independentRows</span><span class="p">(</span><span class="n">basisComplete</span><span class="p">)</span>

            <span class="c1"># the second S and R matrix are:</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">wQ</span><span class="p">[</span><span class="n">indList</span><span class="p">,</span> <span class="p">:])</span> <span class="o">+</span> <span class="n">X</span><span class="p">)</span>
            <span class="n">S2</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">nq</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">F</span><span class="p">))</span>

            <span class="n">R2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">S2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="n">R2</span> <span class="o">=</span> <span class="n">S2</span>

        <span class="k">return</span> <span class="n">S2</span><span class="p">,</span> <span class="n">R2</span>

    <span class="k">def</span> <span class="nf">_transform3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Third transformation of the coordinates that scales the modes.</span>
<span class="sd">        output:</span>
<span class="sd">            --  R3: Third transformation of charge operators (self.n,self.n)</span>
<span class="sd">            --  S3: Third transformation of flux operators (self.n,self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">S3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>

            <span class="c1"># for the charge basis</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])):</span>
                        <span class="c1"># check if abs(A[i,j]/s is either zero or</span>
                        <span class="c1"># one with 1e-11 accuracy</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1e-11</span>
                                <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span>
                                    <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1e-11</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This solver cannot solve&quot;</span>
                                             <span class="s2">&quot; your circuit.&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-11</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">S3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s</span>

                <span class="c1"># correcting the cInvRotated values</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span>
            <span class="c1"># for harmonic modes</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># note: alpha here is absolute value of alpha (alpha is pure</span>
                <span class="c1"># imaginary)</span>

                <span class="c1"># alpha for j-th mode</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span>
                            <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">][</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mf">1e-11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-11</span><span class="p">:</span>
                    <span class="c1"># find the coefficient in wTrans for j-th mode that</span>
                    <span class="c1"># has maximum alpha</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="n">j</span><span class="p">])</span>
                    <span class="c1"># scale that mode with s</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span>
                    <span class="n">S3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">s</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># scale the uncoupled mode</span>
                    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S1</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S2</span><span class="p">)</span>

                    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">S</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>

                    <span class="n">S3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">s</span>

        <span class="n">R3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S3</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S3</span><span class="p">,</span> <span class="n">R3</span>

    <span class="k">def</span> <span class="nf">_transform_hamil</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        transform the Hamiltonian of the circuit that can be expressed</span>
<span class="sd">        in charge and Fock bases</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the first transformation:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform1</span><span class="p">()</span>
        <span class="c1"># second transformation</span>

        <span class="c1"># natural frequencies of the circuit(zero for modes in charge basis)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">))</span>

        <span class="c1"># set the external charge for each charge mode.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">Charge</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>

        <span class="c1"># the case that circuit has no JJ</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># get the second transformation:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S1</span><span class="p">)</span>

            <span class="c1"># apply the second transformation on self.cInvTrans</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span>

            <span class="c1"># get the transformed W matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S1</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># wQ = self.wTrans[:, self.omega == 0]</span>
            <span class="c1"># wQ[np.abs(wQ) &lt; 0.98] = 0</span>
            <span class="c1"># self.wTrans[:, self.omega == 0] = wQ</span>

            <span class="c1"># scaling the modes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform3</span><span class="p">()</span>

            <span class="c1"># The final transformations are:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S1</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S2</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R3</span>

            <span class="c1"># self.cTrans = np.linalg.inv(self.cInvTrans)</span>

<div class="viewcode-block" id="Circuit.description"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.description">[docs]</a>    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">tp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">_test</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print out Hamiltonian and a listing of the modes (whether they are</span>
<span class="sd">        harmonic or charge modes with the frequency for each harmonic mode),</span>
<span class="sd">        Hamiltonian parameters, and external flux values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            tp:</span>
<span class="sd">                If ``None`` prints out the output as Latex if SQcircuit is</span>
<span class="sd">                running in a Jupyter notebook and as text if SQcircuit is</span>
<span class="sd">                running in Python terminal. If ``tp`` is ``&quot;ltx&quot;``,</span>
<span class="sd">                the output is in Latex format if ``tp`` is ``&quot;txt&quot;`` the</span>
<span class="sd">                output is in text format.</span>
<span class="sd">            _test:</span>
<span class="sd">                if True, return the entire description as string</span>
<span class="sd">                text. (use only for testing the function)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_notebook</span><span class="p">():</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="n">HamilTxt</span><span class="p">(</span><span class="s1">&#39;ltx&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="n">HamilTxt</span><span class="p">(</span><span class="s1">&#39;txt&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="n">HamilTxt</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>

        <span class="n">hamilTxt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
        <span class="n">harDim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">chDim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># If circuit has any loop:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">junction_keys</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inductor_keys</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">EJLst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ELLst</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">harDim</span><span class="p">):</span>
            <span class="n">hamilTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">omega</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">ad</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="n">txt</span><span class="o">.</span><span class="n">a</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chDim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chDim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">hamilTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">Ec</span><span class="p">(</span><span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">harDim</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \
                                <span class="n">txt</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">harDim</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>

        <span class="n">JJHamilTxt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">indHamilTxt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">junction_keys</span><span class="p">):</span>
            <span class="n">EJLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">())</span>
            <span class="n">junTxt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">Ej</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span>
            <span class="c1"># if B_idx is not None:</span>
            <span class="n">junTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">txt</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">W</span><span class="p">[</span><span class="n">W_idx</span><span class="p">,</span> <span class="p">:])</span> <span class="o">+</span> \
                      <span class="n">txt</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">txt</span><span class="o">.</span><span class="n">phiExt</span><span class="p">,</span> <span class="n">B</span><span class="p">[</span><span class="n">B_idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">st</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     junTxt += txt.linear(txt.phi, W[W_idx, :])</span>
            <span class="n">JJHamilTxt</span> <span class="o">+=</span> <span class="n">junTxt</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inductor_keys</span><span class="p">):</span>

            <span class="c1"># if np.sum(np.abs(B[B_idx, :])) == 0 or B_idx is None:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">B_idx</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">ELLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">energy</span><span class="p">())</span>
            <span class="n">indTxt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">El</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">harDim</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">indTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">txt</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)(&quot;</span> <span class="o">+</span> \
                      <span class="n">txt</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">txt</span><span class="o">.</span><span class="n">phiExt</span><span class="p">,</span> <span class="n">B</span><span class="p">[</span><span class="n">B_idx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">indHamilTxt</span> <span class="o">+=</span> <span class="n">indTxt</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>

        <span class="n">hamilTxt</span> <span class="o">+=</span> <span class="n">indHamilTxt</span> <span class="o">+</span> <span class="n">JJHamilTxt</span>

        <span class="k">if</span> <span class="s1">&#39;+&#39;</span> <span class="ow">in</span> <span class="n">hamilTxt</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">hamilTxt</span> <span class="o">=</span> <span class="n">hamilTxt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">modeTxt</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">harDim</span><span class="p">):</span>
            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">har</span><span class="p">()</span>

            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">zp</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> \
                       <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">a</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;+&quot;</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">ad</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

            <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">(),</span> <span class="mi">5</span><span class="p">)</span>
            <span class="n">zp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
            <span class="n">zpTxt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:.2e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zp</span><span class="p">)</span>

            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">omega</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">omega</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">zp</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="n">zpTxt</span>

            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chDim</span><span class="p">):</span>
            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">ch</span><span class="p">()</span>
            <span class="n">ng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">ng</span><span class="p">(</span><span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>
            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">paramTxt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">param</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chDim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chDim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">paramTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">Ec</span><span class="p">(</span><span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                       <span class="n">harDim</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">Ec</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">e</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span>
                                <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">())</span> <span class="o">*</span> \
                             <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span>
                                 <span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">harDim</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">Ec</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">e</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span>
                                <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">())</span> <span class="o">*</span> \
                             <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span>
                                 <span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">harDim</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>

                    <span class="n">paramTxt</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Ec</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ELLst</span><span class="p">)):</span>
            <span class="n">paramTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">El</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ELLst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EJLst</span><span class="p">)):</span>
            <span class="n">paramTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">Ej</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">EJLst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>
        <span class="n">paramTxt</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">loopTxt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)):</span>
            <span class="n">phiExt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">loopTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">phiExt</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tPi</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">phiExt</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>

        <span class="n">finalTxt</span> <span class="o">=</span> <span class="n">hamilTxt</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">line</span> <span class="o">+</span> <span class="n">modeTxt</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">line</span> <span class="o">+</span> <span class="n">paramTxt</span> <span class="o">+</span> <span class="n">loopTxt</span>

        <span class="n">txt</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">finalTxt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_test</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">finalTxt</span></div>

<div class="viewcode-block" id="Circuit.loop_description"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.loop_description">[docs]</a>    <span class="k">def</span> <span class="nf">loop_description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_test</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print out the external flux distribution over inductive elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            _test:</span>
<span class="sd">                if True, return the entire description as string</span>
<span class="sd">                text. (use only for testing the function)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># maximum length of element ID strings</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">id_str</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">junction_keys</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">id_str</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inductor_keys</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># maximum length of loop ID strings</span>
        <span class="n">nh</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">id_str</span><span class="p">)</span> <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">])</span>

        <span class="c1"># number of loops</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)</span>

        <span class="c1"># space between elements in rows</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="mi">5</span>

        <span class="n">loop_description_txt</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">+</span> <span class="n">ns</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;, b1:&quot;</span><span class="p">))</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nl</span><span class="p">):</span>
            <span class="n">lp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="n">nh</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">id_str</span><span class="p">))</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">lp</span><span class="o">.</span><span class="n">id_str</span><span class="p">)</span>

        <span class="n">loop_description_txt</span> <span class="o">+=</span> <span class="n">header</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="c1"># add line under header</span>
        <span class="n">loop_description_txt</span> <span class="o">+=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="n">el</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inductor_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">B_idx</span><span class="p">:</span>
                    <span class="n">el</span> <span class="o">=</span> <span class="n">el_ind</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">junction_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">B_idx</span><span class="p">:</span>
                    <span class="n">el</span> <span class="o">=</span> <span class="n">el_ind</span>

            <span class="nb">id</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">id_str</span>
            <span class="n">row</span> <span class="o">=</span> <span class="nb">id</span> <span class="o">+</span> <span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
            <span class="n">bStr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;, b</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">:&quot;</span>
            <span class="n">row</span> <span class="o">+=</span> <span class="n">bStr</span>
            <span class="n">row</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ns</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;, b1:&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">bStr</span><span class="p">))</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nl</span><span class="p">):</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">row</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="n">nh</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">loop_description_txt</span> <span class="o">+=</span> <span class="n">row</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="n">_test</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loop_description_txt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">loop_description_txt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Circuit.set_trunc_nums"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.set_trunc_nums">[docs]</a>    <span class="k">def</span> <span class="nf">set_trunc_nums</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set the truncation numbers for each mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            nums:</span>
<span class="sd">                A list that contains the truncation numbers for each mode.</span>
<span class="sd">                Harmonic modes with truncation number N are 0, 1 , ...,</span>
<span class="sd">                (N-1), and charge modes with truncation number N are -(N-1),</span>
<span class="sd">                ..., 0, ..., (N-1).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">error1</span> <span class="o">=</span> <span class="s2">&quot;The input must be be a python list&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="n">error1</span>
        <span class="n">error2</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The number of modes (length of the input) must be equal to &quot;</span>
                  <span class="s2">&quot;the number of nodes&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">error2</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># for charge modes:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># for harmonic modes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># squeeze the mode with truncation number equal to 1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_build_op_memory</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_LC_hamil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_LC_hamil</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_build_exp_ops</span><span class="p">()</span></div>

<div class="viewcode-block" id="Circuit.set_charge_offset"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.set_charge_offset">[docs]</a>    <span class="k">def</span> <span class="nf">set_charge_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ng</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;set the charge offset for each charge mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mode:</span>
<span class="sd">                An integer that specifies the charge mode. To see, which mode</span>
<span class="sd">                is a charge mode, one can use ``description()`` method.</span>
<span class="sd">            ng:</span>
<span class="sd">                The charge offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;Mode number should be an integer&quot;</span>

        <span class="n">error</span> <span class="o">=</span> <span class="s2">&quot;The specified mode is not a charge mode.&quot;</span>
        <span class="k">assert</span> <span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">,</span> <span class="n">error</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setOffset</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setOffset</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_build_op_memory</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_LC_hamil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_LC_hamil</span><span class="p">()</span></div>

<div class="viewcode-block" id="Circuit.set_charge_noise"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.set_charge_noise">[docs]</a>    <span class="k">def</span> <span class="nf">set_charge_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;set the charge noise for each charge mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mode:</span>
<span class="sd">                An integer that specifies the charge mode. To see which mode</span>
<span class="sd">                is a charge mode, we can use ``description()`` method.</span>
<span class="sd">            A:</span>
<span class="sd">                The charge noise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;Mode number should be an integer&quot;</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">,</span> <span class="s2">&quot;The specified mode &quot;</span> \
                                                <span class="s2">&quot;is not a charge mode.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setNoise</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_squeeze_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="n">Qobj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the same Quantum operator with squeezed dimensions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            op:</span>
<span class="sd">                Any quantum operator in qutip.Qobj format</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">op_sq</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">op_sq</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">op_sq</span>

    <span class="k">def</span> <span class="nf">_build_op_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        build the charge operators, number operators, and cross</span>
<span class="sd">        multiplication of charge operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">charge_ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">flux_ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">charge_by_charge_ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># list of charge operators in their own mode basis</span>
        <span class="c1"># (tensor product of other modes are not applied yet!)</span>
        <span class="n">QList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Q0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">e</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span><span class="p">))</span> <span class="o">*</span> \
                     <span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">charge</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                      <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coef</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
                <span class="n">Q0</span> <span class="o">=</span> <span class="n">coef</span> <span class="o">*</span> <span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">qt</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">QList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q0</span><span class="p">)</span>

        <span class="n">fluxList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># list of flux operators in their own mode basis</span>
        <span class="c1"># (tensor product of other modes are not applied yet!)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flux0</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
                <span class="n">flux0</span> <span class="o">=</span> <span class="n">coef</span> <span class="o">*</span> <span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">qt</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">fluxList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flux0</span><span class="p">)</span>

        <span class="c1"># list of number operators in their own mode basis</span>
        <span class="c1"># (tensor product of other modes are not applied yet!)</span>
        <span class="n">nList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num0</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">charge</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num0</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">nList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">chargeRowList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="c1"># find the appropriate charge and number operator for first mode</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">Q2</span> <span class="o">=</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">nList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">fluxList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                    <span class="c1"># Tensor product the charge with I for other modes</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">Q2</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q2</span><span class="p">,</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="n">chargeRowList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">Q2</span><span class="p">))</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">I</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">I</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">I</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">I</span>

                <span class="c1"># find the rest of the modes</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">I</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">Q2</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">nList</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">fluxList</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                    <span class="c1"># Tensor product the charge with I for other modes</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">Q2</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q2</span><span class="p">,</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="n">chargeRowList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">Q2</span><span class="p">))</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">QQ</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                    <span class="c1"># Tensor product the QQ with I for other modes</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">QQ</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="n">chargeRowList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">QQ</span><span class="p">))</span>

                    <span class="n">I</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

            <span class="n">charge_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
            <span class="n">charge_by_charge_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chargeRowList</span><span class="p">)</span>
            <span class="n">flux_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
            <span class="n">num_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">charge_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;QQ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">charge_by_charge_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_ops</span>

    <span class="k">def</span> <span class="nf">_get_LC_hamil</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the LC part of the Hamiltonian</span>
<span class="sd">        outputs:</span>
<span class="sd">            -- HLC: LC part of the Hamiltonian (qutip Object)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">LC_hamil</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># we write j in this form because of &quot;_memory_ops[&quot;QQ&quot;]&quot; shape</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">LC_hamil</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                                     <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;QQ&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">LC_hamil</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">LC_hamil</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
                                     <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;QQ&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">LC_hamil</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_d_op</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return charge displacement operator with size N.</span>
<span class="sd">        input:</span>
<span class="sd">            -- N: size of the Hilbert Space</span>
<span class="sd">        output:</span>
<span class="sd">            -- d: charge displace ment operator( qutip object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_build_exp_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Each cosine potential of the Josephson Junction can be written as</span>
<span class="sd">        summation of two exponential terms,cos(x)=(exp(ix)+exp(-ix))/2. This</span>
<span class="sd">        function returns the quantum operators for only one exponential term.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">exp_ops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">root_exp_ops</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># number of Josephson Junctions</span>
        <span class="n">nJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">H</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># for calculating sin(phi/2) operator for quasi-particle</span>
        <span class="c1"># loss decay rate</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nJ</span><span class="p">):</span>

            <span class="c1"># tensor multiplication of displacement operator for JJ Hamiltonian</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">I</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">I</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="c1"># not correct just to avoid error:</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">I</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
                        <span class="c1"># not correct just to avoid error:</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">I</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span> <span class="o">*</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">H</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">alpha</span><span class="p">)</span>
                    <span class="n">H2</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span> <span class="o">*</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">H</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">qt</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">alpha</span><span class="p">))</span>
                    <span class="n">H2</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="n">qt</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

            <span class="n">exp_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">H</span><span class="p">))</span>
            <span class="n">root_exp_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">H2</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;root_exp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_exp_ops</span>

    <span class="k">def</span> <span class="nf">_get_external_flux_at_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the external flux at an inductive element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            B_idx:</span>
<span class="sd">                An integer point to each row of B matrix (external flux</span>
<span class="sd">                distribution of that element)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi_ext</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">):</span>
            <span class="n">phi_ext</span> <span class="o">+=</span> <span class="n">loop</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">B_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">phi_ext</span>

    <span class="k">def</span> <span class="nf">_get_inductive_hamil</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inductor_keys</span><span class="p">:</span>
            <span class="c1"># phi = 0</span>
            <span class="c1"># if B_idx is not None:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_external_flux_at_element</span><span class="p">(</span><span class="n">B_idx</span><span class="p">)</span>

            <span class="c1"># summation of the 1 over inductor values.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">el</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">)</span>
            <span class="n">O</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_op</span><span class="p">(</span><span class="s2">&quot;inductive&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
            <span class="n">H</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">*</span> <span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">O</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span><span class="p">)</span>

            <span class="c1"># save the operators for loss calculation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;ind_hamil&quot;</span><span class="p">][(</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">O</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">junction_keys</span><span class="p">:</span>
            <span class="c1"># phi = 0</span>
            <span class="c1"># if B_idx is not None:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_external_flux_at_element</span><span class="p">(</span><span class="n">B_idx</span><span class="p">)</span>

            <span class="n">EJ</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">)</span>

            <span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">][</span><span class="n">W_idx</span><span class="p">]</span>
            <span class="n">root_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;root_exp&quot;</span><span class="p">][</span>
                <span class="n">W_idx</span><span class="p">]</span>

            <span class="n">cos</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span> <span class="o">+</span> <span class="n">exp</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="n">exp</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="n">j</span>
            <span class="n">sin_half</span> <span class="o">=</span> <span class="p">(</span><span class="n">root_exp</span> <span class="o">-</span> <span class="n">root_exp</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="n">j</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;cos&quot;</span><span class="p">][</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">cos</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;sin&quot;</span><span class="p">][</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">sin</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;sin_half&quot;</span><span class="p">][</span><span class="n">el</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">sin_half</span><span class="p">)</span>

            <span class="n">H</span> <span class="o">+=</span> <span class="o">-</span><span class="n">EJ</span> <span class="o">*</span> <span class="n">cos</span>

        <span class="k">return</span> <span class="n">H</span>

<div class="viewcode-block" id="Circuit.diag"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.diag">[docs]</a>    <span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_eig</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Qobj</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Diagonalize the Hamiltonian of the circuit and return the</span>
<span class="sd">        eigenfrequencies and eigenvectors of the circuit up to specified</span>
<span class="sd">        number of eigenvalues.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            n_eig:</span>
<span class="sd">                Number of eigenvalues to output. The lower ``n_eig``, the</span>
<span class="sd">                faster ``SQcircuit`` finds the eigenvalues.</span>
<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            efreq:</span>
<span class="sd">                ndarray of eigenfrequencies in frequency unit of SQcircuit (</span>
<span class="sd">                gigahertz by default)</span>
<span class="sd">            evecs:</span>
<span class="sd">                List of eigenvectors in qutip.Qobj format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error1</span> <span class="o">=</span> <span class="s2">&quot;Please specify the truncation number for each mode.&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error1</span>
        <span class="n">error2</span> <span class="o">=</span> <span class="s2">&quot;n_eig (number of eigenvalues) should be an integer.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_eig</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="n">error2</span>

        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">()</span>

        <span class="c1"># get the data out of qutip variable and use sparse scipy eigen</span>
        <span class="c1"># solver which is faster.</span>
        <span class="n">efreqs</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigs</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">n_eig</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SR&#39;</span><span class="p">)</span>
        <span class="c1"># the output of eigen solver is not sorted</span>
        <span class="n">efreqs_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">efreqs</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

        <span class="n">sort_arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">efreqs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sort_arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">sort_arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">sort_arg</span><span class="p">]</span>

        <span class="n">evecs_sorted</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">evecs</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">sort_arg</span>
        <span class="p">]</span>

        <span class="c1"># store the eigenvalues and eigenvectors of the circuit Hamiltonian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span> <span class="o">=</span> <span class="n">efreqs_sorted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span> <span class="o">=</span> <span class="n">evecs_sorted</span>

        <span class="k">return</span> <span class="n">efreqs_sorted</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">unt</span><span class="o">.</span><span class="n">get_unit_freq</span><span class="p">()),</span> <span class="n">evecs_sorted</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1"># Methods that calculate circuit properties</span>
    <span class="c1">###########################################################################</span>

<div class="viewcode-block" id="Circuit.coord_transform"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.coord_transform">[docs]</a>    <span class="k">def</span> <span class="nf">coord_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the transformation of the coordinates as ndarray for each type</span>
<span class="sd">        of variables, either charge or flux.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            var_type:</span>
<span class="sd">                The type of the variables that can be either ``&quot;charge&quot;`` or</span>
<span class="sd">                ``&quot;flux&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s2">&quot;charge&quot;</span> <span class="ow">or</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s2">&quot;Charge&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s2">&quot;flux&quot;</span> <span class="ow">or</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s2">&quot;Flux&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input must be either </span><span class="se">\&quot;</span><span class="s2">charge</span><span class="se">\&quot;</span><span class="s2"> or </span><span class="se">\&quot;</span><span class="s2">flux</span><span class="se">\&quot;</span><span class="s2">.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Circuit.hamiltonian"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the transformed hamiltonian of the circuit as</span>
<span class="sd">        qutip.Qobj format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error</span> <span class="o">=</span> <span class="s2">&quot;Please specify the truncation number for each mode.&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error</span>

        <span class="n">Hind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_inductive_hamil</span><span class="p">()</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">Hind</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LC_hamil</span>

        <span class="k">return</span> <span class="n">H</span></div>

    <span class="k">def</span> <span class="nf">_tensor_to_modes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensorIndex</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        decomposes the tensor product space index to each mode indices. For</span>
<span class="sd">        example index 5 of the tensor product space can be decomposed to [1,</span>
<span class="sd">        0,1] modes if the truncation number for each mode is 2.</span>
<span class="sd">        inputs:</span>
<span class="sd">            -- tensorIndex: Index of tensor product space</span>
<span class="sd">        outputs:</span>
<span class="sd">            -- indList: a list of mode indices (self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># i-th mP element is the multiplication of the self.m elements until</span>
        <span class="c1"># its i-th element</span>
        <span class="n">mP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mP</span> <span class="o">=</span> <span class="p">[</span><span class="n">mP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">mP</span>

        <span class="n">indList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">indexP</span> <span class="o">=</span> <span class="n">tensorIndex</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indexP</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">indList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">indexP</span> <span class="o">/</span> <span class="n">mP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">indexP</span> <span class="o">=</span> <span class="n">indexP</span> <span class="o">%</span> <span class="n">mP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">indList</span>

<div class="viewcode-block" id="Circuit.eig_phase_coord"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.eig_phase_coord">[docs]</a>    <span class="k">def</span> <span class="nf">eig_phase_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the phase coordinate representations of the eigenvectors as</span>
<span class="sd">        ndarray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            k:</span>
<span class="sd">                The eigenvector index. For example, we set it to 0 for the</span>
<span class="sd">                ground state and 1 for the first excited state.</span>
<span class="sd">            grid:</span>
<span class="sd">                A list that contains the range of values of phase φ for which</span>
<span class="sd">                we want to evaluate the wavefunction.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;The k (index of eigenstate) should be &quot;</span>
                                    <span class="s2">&quot;an integer.&quot;</span><span class="p">)</span>

        <span class="n">phi_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grid</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)]</span>

        <span class="c1"># The total dimension of the circuit Hilbert Space</span>
        <span class="n">netDimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>

        <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">netDimension</span><span class="p">):</span>

            <span class="c1"># decomposes the tensor product space index (i) to each mode</span>
            <span class="c1"># indices as a list</span>
            <span class="n">indList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_to_modes</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>

                <span class="c1"># mode number related to that node</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">indList</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>

                <span class="c1"># For charge basis</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">term</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                        <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi_list</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
                <span class="c1"># For harmonic basis</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">mode</span><span class="p">,</span> <span class="n">mode</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">mode</span><span class="p">,</span> <span class="n">mode</span><span class="p">]))</span>

                    <span class="n">coef</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span>
                                       <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span>
                                           <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">/</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span><span class="p">)</span>

                    <span class="n">term</span> <span class="o">*=</span> <span class="n">coef</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                        <span class="o">-</span><span class="p">(</span><span class="n">phi_list</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">*</span><span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span><span class="o">/</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
                            <span class="n">eval_hermite</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">phi_list</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="n">x0</span><span class="p">)</span>

            <span class="n">state</span> <span class="o">+=</span> <span class="n">term</span>

        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1"># transposing the first two modes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indModes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
            <span class="n">indModes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">indModes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">indModes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">state</span></div>

<div class="viewcode-block" id="Circuit.coupling_op"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.coupling_op">[docs]</a>    <span class="k">def</span> <span class="nf">coupling_op</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ctype</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the capacitive or inductive coupling operator related to the</span>
<span class="sd">        specified nodes. The output has the `qutip.Qobj` format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            ctype:</span>
<span class="sd">                Coupling type which is either ``&quot;capacitive&quot;`` or</span>
<span class="sd">                ``&quot;inductive&quot;``.</span>
<span class="sd">            nodes:</span>
<span class="sd">                A tuple of circuit nodes to which we want to couple.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error1</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The coupling type must be either </span><span class="se">\&quot;</span><span class="s2">capacitive</span><span class="se">\&quot;</span><span class="s2"> or &quot;</span>
                  <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">inductive</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">ctype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;capacitive&quot;</span><span class="p">,</span> <span class="s2">&quot;inductive&quot;</span><span class="p">],</span> <span class="n">error1</span>
        <span class="n">error2</span> <span class="o">=</span> <span class="s2">&quot;Nodes must be a tuple of int&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="n">error2</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="n">node1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># for the case that we have ground in the edge</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node1</span> <span class="o">+</span> <span class="n">node2</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;capacitive&quot;</span><span class="p">:</span>
                <span class="c1"># K = np.linalg.inv(self.getMatC()) @ self.R</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">K</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;inductive&quot;</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">K</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;capacitive&quot;</span><span class="p">:</span>
                <span class="c1"># K = np.linalg.inv(self.getMatC()) @ self.R</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">node2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">K</span><span class="p">[</span><span class="n">node1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="o">*</span> \
                          <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;inductive&quot;</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="p">((</span><span class="n">K</span><span class="p">[</span><span class="n">node1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">K</span><span class="p">[</span><span class="n">node2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                           <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span></div>

<div class="viewcode-block" id="Circuit.matrix_elements"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.matrix_elements">[docs]</a>    <span class="k">def</span> <span class="nf">matrix_elements</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ctype</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
            <span class="n">states</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the matrix element of two eigenstates for either capacitive</span>
<span class="sd">        or inductive coupling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            ctype:</span>
<span class="sd">                Coupling type which is either ``&quot;capacitive&quot;`` or</span>
<span class="sd">                ``&quot;inductive&quot;``.</span>
<span class="sd">            nodes:</span>
<span class="sd">                A tuple of circuit nodes to which we want to couple.</span>
<span class="sd">            states:</span>
<span class="sd">                A tuple of indices of eigenstates for which we want to</span>
<span class="sd">                calculate the matrix element.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">state1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">state2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># get the coupling operator</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_op</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_dephasing</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">partial_omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculate dephasing rate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            A:</span>
<span class="sd">                Noise Amplitude</span>
<span class="sd">            partial_omega:</span>
<span class="sd">                The derivatives of angular frequency with respect to the</span>
<span class="sd">                noisy parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">partial_omega</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;omega_low&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;t_exp&quot;</span><span class="p">]))))</span>

<div class="viewcode-block" id="Circuit.dec_rate"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.dec_rate">[docs]</a>    <span class="k">def</span> <span class="nf">dec_rate</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dec_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">states</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
            <span class="n">total</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Return the decoherence rate in [1/s] between each two eigenstates</span>
<span class="sd">        for different types of depolarization and dephasing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            dec_type:</span>
<span class="sd">                decoherence type that can be: ``&quot;capacitive&quot;`` for capacitive</span>
<span class="sd">                loss; ``&quot;inductive&quot;`` for inductive loss; `&quot;quasiparticle&quot;` for</span>
<span class="sd">                quasiparticle loss; ``&quot;charge&quot;`` for charge noise, ``&quot;flux&quot;``</span>
<span class="sd">                for flux noise; and ``&quot;cc&quot;`` for critical current noise.</span>
<span class="sd">            states:</span>
<span class="sd">                A tuple of eigenstate indices, for which we want to</span>
<span class="sd">                calculate the decoherence rate. For example, for ``states=(0,</span>
<span class="sd">                1)``, we calculate the decoherence rate between the ground</span>
<span class="sd">                state and the first excited state.</span>
<span class="sd">            total:</span>
<span class="sd">                if False return a decoherence rate associated with a</span>
<span class="sd">                transition from state m to state n for ``states=(m, n)``. if</span>
<span class="sd">                True return a decoherence rate associated with both m to n</span>
<span class="sd">                and n to m transitions.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">omega1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">omega2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_efreqs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">state1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">state2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">omega2</span> <span class="o">-</span> <span class="n">omega1</span><span class="p">)</span>

        <span class="n">decay</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># prevent the exponential overflow(exp(709) is the biggest number</span>
        <span class="c1"># that numpy can calculate</span>
        <span class="k">if</span> <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">/</span> <span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">k_B</span> <span class="o">*</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">709</span><span class="p">:</span>
            <span class="n">down</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">up</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">/</span> <span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">k_B</span> <span class="o">*</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span>
            <span class="n">down</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">up</span> <span class="o">=</span> <span class="n">down</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span>

        <span class="c1"># for temperature dependent loss</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">total</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">tempS</span> <span class="o">=</span> <span class="n">down</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tempS</span> <span class="o">=</span> <span class="n">up</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tempS</span> <span class="o">=</span> <span class="n">down</span> <span class="o">+</span> <span class="n">up</span>

        <span class="k">if</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;capacitive&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">edge</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Capacitor</span><span class="p">):</span>
                        <span class="n">cap</span> <span class="o">=</span> <span class="n">el</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cap</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">cap</span>
                    <span class="k">if</span> <span class="n">cap</span><span class="o">.</span><span class="n">Q</span><span class="p">:</span>
                        <span class="n">decay</span> <span class="o">+=</span> <span class="n">tempS</span> <span class="o">*</span> <span class="n">cap</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">/</span> <span class="n">cap</span><span class="o">.</span><span class="n">Q</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">matrix_elements</span><span class="p">(</span>
                                <span class="s2">&quot;capacitive&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">states</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;inductive&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;ind_hamil&quot;</span><span class="p">]:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;ind_hamil&quot;</span><span class="p">][(</span><span class="n">el</span><span class="p">,</span> <span class="n">_</span><span class="p">)]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">el</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">Q</span><span class="p">:</span>
                    <span class="n">decay</span> <span class="o">+=</span> <span class="n">tempS</span> <span class="o">/</span> <span class="n">el</span><span class="o">.</span><span class="n">Q</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;quasiparticle&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;sin_half&#39;</span><span class="p">]:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;sin_half&#39;</span><span class="p">][(</span><span class="n">el</span><span class="p">,</span> <span class="n">_</span><span class="p">)]</span>
                <span class="n">decay</span> <span class="o">+=</span> <span class="n">tempS</span> <span class="o">*</span> <span class="n">el</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">ENV</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">el</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> \
                         <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">elif</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;charge&quot;</span><span class="p">:</span>
            <span class="c1"># first derivative of the Hamiltonian with respect to charge noise</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">op</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                               <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span><span class="p">))</span>
                    <span class="n">partial_omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">state2</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">state2</span> <span class="o">-</span>
                                            <span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">state1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_islands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">decay</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dephasing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">partial_omega</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;cc&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">]:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">][(</span><span class="n">el</span><span class="p">,</span> <span class="n">_</span><span class="p">)]</span>
                <span class="n">partial_omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">state2</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">state2</span>
                                        <span class="o">-</span> <span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">state1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">A</span>
                <span class="n">decay</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dephasing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">partial_omega</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">dec_type</span> <span class="o">==</span> <span class="s2">&quot;flux&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
                <span class="n">partial_omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_partial_omega</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="n">states</span><span class="p">)</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">A</span>
                <span class="n">decay</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dephasing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">partial_omega</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">decay</span></div>

    <span class="k">def</span> <span class="nf">_get_partial_H</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">el</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Capacitor</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">,</span> <span class="n">Junction</span><span class="p">,</span> <span class="n">Loop</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qobj</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return the gradient of the Hamiltonian with respect to elements or</span>
<span class="sd">        loop as ``qutip.Qobj`` format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            el:</span>
<span class="sd">                element of a circuit that can be either ``Capacitor``,</span>
<span class="sd">                ``Inductor``, ``Junction``, or ``Loop``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">partial_H</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Loop</span><span class="p">):</span>

            <span class="n">loop_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
            <span class="c1"># note that this is not b_i</span>
            <span class="c1"># k = self.B[:, idx]</span>

            <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">,</span> <span class="n">B_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inductor_keys</span><span class="p">:</span>
                <span class="n">partial_H</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">B_idx</span><span class="p">,</span> <span class="n">loop_idx</span><span class="p">]</span>
                              <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s2">&quot;ind_hamil&quot;</span><span class="p">][(</span><span class="n">el_ind</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)]</span>
                              <span class="o">/</span> <span class="n">el_ind</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">*</span> <span class="n">unt</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">unt</span><span class="o">.</span><span class="n">hbar</span><span class="p">)</span>
                              <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">,</span> <span class="n">W_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">junction_keys</span><span class="p">:</span>
                <span class="n">partial_H</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">B_idx</span><span class="p">,</span> <span class="n">loop_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">el_ind</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
                              <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_ops</span><span class="p">[</span><span class="s1">&#39;sin&#39;</span><span class="p">][(</span><span class="n">el_ind</span><span class="p">,</span> <span class="n">B_idx</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">partial_H</span>

    <span class="k">def</span> <span class="nf">_get_partial_omega</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">el</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Capacitor</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">,</span> <span class="n">Junction</span><span class="p">,</span> <span class="n">Loop</span><span class="p">],</span>
            <span class="n">states</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return the gradient of the eigen angular frequency with respect to</span>
<span class="sd">        elements or loop as ``qutip.Qobj`` format. Note that if</span>
<span class="sd">        ``states=(m, n)``, it returns ``partial_omega_m - partial_omega_n``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            el:</span>
<span class="sd">                element of a circuit that can be either ``Capacitor``,</span>
<span class="sd">                ``Inductor``, ``Junction``, or ``Loop``.</span>
<span class="sd">            states:</span>
<span class="sd">                A tuple of eigenstate indices, for which we want to</span>
<span class="sd">                calculate the decoherence rate. For example, for ``states=(0,</span>
<span class="sd">                1)``, we calculate the decoherence rate between the ground</span>
<span class="sd">                state and the first excited state.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">state_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evecs</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">partial_H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_partial_H</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>

        <span class="n">partial_omega_m</span> <span class="o">=</span> <span class="n">state_m</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">partial_H</span> <span class="o">*</span> <span class="n">state_m</span><span class="p">)</span>
        <span class="n">partial_omega_n</span> <span class="o">=</span> <span class="n">state_n</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">partial_H</span> <span class="o">*</span> <span class="n">state_n</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">partial_omega_m</span> <span class="o">-</span> <span class="n">partial_omega_n</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Taha Rajabzadeh, Amir Safavi-Naeini.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>