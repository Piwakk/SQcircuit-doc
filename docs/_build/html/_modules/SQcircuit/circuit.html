<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SQcircuit.circuit &mdash; SQcircuit 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> SQcircuit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickTutorial.html">Quick Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/guides.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html#contributors">Contributors</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SQcircuit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>SQcircuit.circuit</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for SQcircuit.circuit</h1><div class="highlight"><pre>
<span></span><span class="c1"># Libraries:</span>

<span class="kn">from</span> <span class="nn">SQcircuit.elements</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">SQcircuit.latexUtils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">SQcircuit.physParam</span> <span class="k">as</span> <span class="nn">phPar</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="k">as</span> <span class="nn">q</span>

<span class="kn">import</span> <span class="nn">scipy.special</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">sqrtm</span><span class="p">,</span> <span class="n">block_diag</span>


<div class="viewcode-block" id="Circuit"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit">[docs]</a><span class="k">class</span> <span class="nc">Circuit</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that contains the circuit properties and uses the theory discussed in the original</span>
<span class="sd">    paper of the SQcircuit to calculate:</span>

<span class="sd">        * Eigenvalues and eigenvectors</span>
<span class="sd">        * Phase coordinate representation of eigenvectors</span>
<span class="sd">        * Coupling operators</span>
<span class="sd">        * Matrix elements</span>
<span class="sd">        * Decoherence rates</span>
<span class="sd">        * Robustness analysis</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        elements: dict</span>
<span class="sd">            A dictionary that contains the circuit&#39;s elements at each branch of the circuit.</span>
<span class="sd">        random: bool</span>
<span class="sd">            If `True`, each element of the circuit is a random number due to fabrication error. This</span>
<span class="sd">            is necessary for robustness analysis.</span>
<span class="sd">        fluxDist: str</span>
<span class="sd">            Provide the method of distributing the external fluxes. If ``fluxDist`` is ``&quot;all&quot;``,</span>
<span class="sd">            SQcircuit assign the external fluxes based on the capacitor of each inductive element</span>
<span class="sd">            (This option is necessary for time-dependent external fluxes).</span>
<span class="sd">            If `fluxDist` is `&quot;inductor&quot;` SQcircuit finds the external flux distribution by assuming the</span>
<span class="sd">            capacitor of the inductors are much smaller than the junction capacitors, If `fluxDist` is `&quot;junction&quot;`</span>
<span class="sd">            it is the other way around.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># external charges of the circuit</span>
    <span class="n">extCharge</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># list of charge operators( transformed operators) (self.n)</span>
    <span class="n">chargeOpList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># list of flux operators(transformed operators) (self.n)</span>
    <span class="n">fluxOpList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># cross multiplication of charge operators as list</span>
    <span class="n">chargeByChargeList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># list of number operators (self.n)</span>
    <span class="n">numOpList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># LC part of the Hamiltonian</span>
    <span class="n">HLC</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
    <span class="c1"># List of exponential part of the Josephson Junction cosine</span>
    <span class="n">HJJExpList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># List of square root of exponential part of</span>
    <span class="n">HJJExpRootList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># sin(phi/2) operator related to each JJ for quasi-particle Loss</span>
    <span class="n">qpSinList</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># eigenvalues of the circuit</span>
    <span class="n">hamilEigVal</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># eigenvectors of the circuit</span>
    <span class="n">hamilEigVec</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># temperature of the circuit</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mf">0.015</span>
    <span class="c1"># low-frequency cut off</span>
    <span class="n">omegaLow</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="c1"># high-frequency cut off</span>
    <span class="n">omegaHigh</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mf">1e9</span>
    <span class="c1"># experiment time</span>
    <span class="n">tExp</span> <span class="o">=</span> <span class="mf">10e-6</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">random</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">fluxDist</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;junctions&#39;</span><span class="p">):</span>

        <span class="c1"># circuit inductive loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loops</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># external charges of the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extCharge</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># loop distribution over inductive elements.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K2</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">elements</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="n">random</span>

        <span class="n">error</span> <span class="o">=</span> <span class="s2">&quot;fluxDist option must be either </span><span class="se">\&quot;</span><span class="s2">junctions</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">inductors</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">all</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="n">fluxDist</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;junctions&quot;</span><span class="p">,</span> <span class="s2">&quot;Junctions&quot;</span><span class="p">,</span> <span class="s2">&quot;inductors&quot;</span><span class="p">,</span> <span class="s2">&quot;Inductors&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;All&quot;</span><span class="p">],</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">=</span> <span class="n">fluxDist</span>

        <span class="c1"># number of nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">))</span>

        <span class="c1"># number of branches that contain JJ without parallel inductor.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># inductive element List</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indElemLst</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># get the capacitance matrix, inductance matrix, and w matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loopLCW</span><span class="p">()</span>

        <span class="c1"># the inverse of transformation of coordinates for charge operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="c1"># the inverse of transformation of coordinates for flux operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="c1"># S and R matrix of first, second, and third transformation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="c1"># diagonalized sudo-inductance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="c1"># transformed capacitance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cTrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="c1"># transformed inverse capacitance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="c1"># transformed w matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span>

        <span class="c1"># natural angular frequencies of the circuit(zero for modes in charge basis)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># transform the Hamiltonian of the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformHamil</span><span class="p">()</span>

        <span class="c1"># truncation numbers for each mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># squeezed truncation numbers( eliminating the modes with truncation number equals 1)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="n">typeAttrs</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="n">selfDict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">typeAttrs</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">selfDict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">state</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">elementModel</span><span class="p">(</span><span class="n">elementList</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            get the list of element with specific model from the list of elements.</span>
<span class="sd">            inputs:</span>
<span class="sd">                -- elementList: a list of objects from Capacitor, Inductor, and JJ class.</span>
<span class="sd">                -- model: model of the element( can be Capacitor, Inductor, or JJ)</span>
<span class="sd">            outputs:</span>
<span class="sd">                -- modelList: list of element with specified model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elementList</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">model</span><span class="p">)]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_independentRows</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;use Gram–Schmidt to find the linear independent rows of matrix A</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># normalize the row of matrix A</span>
        <span class="n">A_norm</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">indList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_norm</span><span class="p">):</span>
            <span class="n">aPrime</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="o">*</span> <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">aPrime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">indList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aPrime</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">aPrime</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">indList</span><span class="p">,</span> <span class="n">basis</span>

    <span class="k">def</span> <span class="nf">addLoop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add loop to the circuit loops.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">loop</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">loopLCW</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculate the capacitance matrix, inductance matrix, w matrix, and the flux distribution over</span>
<span class="sd">        inductive elements.</span>
<span class="sd">        outputs:</span>
<span class="sd">            -- cMat: capacitance matrix (self.n,self.n)</span>
<span class="sd">            -- lMat: inductance matrix (self.n,self.n)</span>
<span class="sd">            -- wMat:  W matrix(linear combination of the flux node operators in the JJ cosine (n_J,self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="n">lMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="n">wMat</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># count of inductive elements</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># number of branches that contain JJ without parallel inductor.</span>
        <span class="n">countJJnoInd</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># K1 is a matrix that transfer node coordinates to edge phase drop for inductive elements</span>
        <span class="n">K1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># capacitor at each inductive elements</span>
        <span class="n">cEd</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># i1 and i2 are the nodes of the edge</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">edge</span>

            <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">w</span><span class="p">[</span><span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">w</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="c1"># elements of the edge</span>
            <span class="n">edgeElements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>

            <span class="c1"># list of capacitors of the edge.</span>
            <span class="n">capList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># list of inductors of the edge</span>
            <span class="n">indList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># list of Josephson Junction of the edge.</span>
            <span class="n">JJList</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">edgeElements</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Capacitor</span><span class="p">):</span>
                    <span class="n">capList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indElemLst</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">])</span>
                    <span class="n">indList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                    <span class="c1"># capacitor of inductor</span>
                    <span class="n">capList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="p">)</span>
                    <span class="n">loops</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">loops</span>
                    <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">loops</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">addLoop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
                        <span class="n">loop</span><span class="o">.</span><span class="n">addIndex</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
                        <span class="n">loop</span><span class="o">.</span><span class="n">addK1</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="n">K1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s2">&quot;junctions&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s2">&quot;Junctions&quot;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Capacitor</span><span class="p">(</span><span class="mf">1e20</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s2">&quot;inductors&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s2">&quot;Inductors&quot;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Capacitor</span><span class="p">(</span><span class="mf">1e-20</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>

                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Junction</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indElemLst</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">])</span>
                    <span class="n">JJList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                    <span class="c1"># capacitor of JJ</span>
                    <span class="n">capList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="p">)</span>
                    <span class="n">loops</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">loops</span>
                    <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">loops</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">addLoop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
                        <span class="n">loop</span><span class="o">.</span><span class="n">addIndex</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
                        <span class="n">loop</span><span class="o">.</span><span class="n">addK1</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="n">K1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cap</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s2">&quot;junctions&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s2">&quot;Junctions&quot;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Capacitor</span><span class="p">(</span><span class="mf">1e-20</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s2">&quot;inductors&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxDist</span> <span class="o">==</span> <span class="s2">&quot;Inductors&quot;</span><span class="p">:</span>
                        <span class="n">cEd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Capacitor</span><span class="p">(</span><span class="mf">1e20</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>

                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">JJList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">countJJnoInd</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># summation of the capacitor values.</span>
            <span class="n">cap</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">),</span> <span class="n">capList</span><span class="p">)))</span>

            <span class="c1"># summation of the one over inductor values.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">),</span> <span class="n">indList</span><span class="p">))))</span>

            <span class="k">if</span> <span class="n">i1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cap</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="k">elif</span> <span class="n">i1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cap</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">cap</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">cap</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cap</span>
                <span class="n">cMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cap</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>
                <span class="n">lMat</span><span class="p">[</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">JJList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">wMat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">wMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wMat</span><span class="p">)</span>

        <span class="n">K1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">K1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">K1</span><span class="p">)</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K1</span> <span class="o">!=</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="c1"># eliminate the zero columns</span>
        <span class="n">K1</span> <span class="o">=</span> <span class="n">K1</span><span class="p">[:,</span> <span class="n">select</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">K1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">K1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">K1</span> <span class="o">=</span> <span class="n">K1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">K1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cEd</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
            <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">loop</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">getP</span><span class="p">()</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># number of inductive loops of the circuit</span>
        <span class="n">numLoop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numLoop</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">count</span> <span class="o">-</span> <span class="n">numLoop</span><span class="p">,</span> <span class="n">numLoop</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">numLoop</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">@</span> <span class="n">Y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span> <span class="o">=</span> <span class="n">countJJnoInd</span>

        <span class="k">return</span> <span class="n">cMat</span><span class="p">,</span> <span class="n">lMat</span><span class="p">,</span> <span class="n">wMat</span>

    <span class="k">def</span> <span class="nf">transform1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First transformation of the coordinates that simultaneously diagonalizes</span>
<span class="sd">        the capacitance and inductance matrices.</span>

<span class="sd">        output:</span>
<span class="sd">            --  lTrans: diagonalized sudo-inductance matrix (self.n,self.n)</span>
<span class="sd">            --  cInvTrans: diagonalized inverse of capacitance matrix (self.n,self.n)</span>
<span class="sd">            --  R1: transformation of charge operators (self.n,self.n)</span>
<span class="sd">            --  S1: transformation of flux operators (self.n,self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># cMat = self.getMatC()</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span>
        <span class="c1"># lMat = self.getMatL()</span>
        <span class="n">lMat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="n">cMatInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cMat</span><span class="p">)</span>

        <span class="n">cMatRoot</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">cMat</span><span class="p">)</span>
        <span class="n">cMatRootInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cMatRoot</span><span class="p">)</span>
        <span class="n">lMatRoot</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">lMat</span><span class="p">)</span>

        <span class="n">V</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">lMatRoot</span> <span class="o">@</span> <span class="n">cMatRootInv</span><span class="p">)</span>

        <span class="c1"># the case that there is not any inductor in the circuit</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
            <span class="n">singLoc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># find the number of singularity in the circuit</span>
            <span class="n">lEig</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">lMat</span><span class="p">)</span>
            <span class="n">numSing</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lEig</span><span class="p">[</span><span class="n">lEig</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lEig</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-11</span><span class="p">])</span>
            <span class="n">singLoc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">numSing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
            <span class="n">D</span><span class="p">[</span><span class="n">singLoc</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

        <span class="c1"># build S1 and R1 matrix</span>
        <span class="n">S1</span> <span class="o">=</span> <span class="n">cMatRootInv</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
        <span class="n">R1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">cInvTrans</span> <span class="o">=</span> <span class="n">R1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">cMatInv</span> <span class="o">@</span> <span class="n">R1</span>
        <span class="n">lTrans</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">lMat</span> <span class="o">@</span> <span class="n">S1</span>

        <span class="n">lTrans</span><span class="p">[</span><span class="n">singLoc</span><span class="p">,</span> <span class="n">singLoc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">lTrans</span><span class="p">,</span> <span class="n">cInvTrans</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span> <span class="n">R1</span>

    <span class="k">def</span> <span class="nf">transform2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">S1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Second transformation of the coordinates that transforms the subspace of</span>
<span class="sd">        the charge operators which are defined in the charge basis in order</span>
<span class="sd">        to have the Bloch wave vectors in the cartesian direction.</span>
<span class="sd">        output:</span>
<span class="sd">            --  R2: Second transformation of charge operators (self.n,self.n)</span>
<span class="sd">            --  S2: Second transformation of flux operators (self.n,self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># apply the first transformation on w and get the charge basis part</span>
        <span class="c1"># wTrans1 = self.getMatW() @ S1</span>
        <span class="n">wTrans1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">@</span> <span class="n">S1</span>
        <span class="n">wQ</span> <span class="o">=</span> <span class="n">wTrans1</span><span class="p">[:,</span> <span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># wQ[np.abs(wQ) &lt; 1e-2] = 0</span>
        <span class="c1"># a = np.zeros_like(wQ)</span>
        <span class="c1"># select = np.sum(wQ != a, axis=0) != 0</span>
        <span class="c1"># # eliminate the zero columns</span>
        <span class="c1"># wQ = wQ[:, select]</span>

        <span class="c1"># number of operators represented in charge bases</span>
        <span class="n">nq</span> <span class="o">=</span> <span class="n">wQ</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># if we need to represent an operator in charge basis</span>
        <span class="k">if</span> <span class="n">nq</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># normalizing the wQ vectors(each row is a vector)</span>
            <span class="c1"># wQ_norm = wQ / np.linalg.norm(wQ, axis=1).reshape(wQ.shape[0], 1)</span>

            <span class="c1"># list of indices of w vectors that are independent</span>
            <span class="n">indList</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># use Gram–Schmidt to find the linear independent rows of normalized wQ (wQ_norm)</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nq</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">indList</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_independentRows</span><span class="p">(</span><span class="n">wQ</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># to complete the basis</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nq</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">),</span> <span class="n">nq</span><span class="p">))</span>
                    <span class="n">basisComplete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">basis</span> <span class="o">+</span> <span class="n">X</span><span class="p">)</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_independentRows</span><span class="p">(</span><span class="n">basisComplete</span><span class="p">)</span>

                <span class="c1"># for i, w in enumerate(wQ_norm):</span>
                <span class="c1">#     wPrime = w - sum([np.dot(w, e) * e for e in basis])</span>
                <span class="c1">#     if (np.abs(wPrime) &gt; 1e-7).any():</span>
                <span class="c1">#         indList.append(i)</span>
                <span class="c1">#         basis.append(wPrime / np.linalg.norm(wPrime))</span>

            <span class="c1"># the second S and R matrix are:</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">wQ</span><span class="p">[</span><span class="n">indList</span><span class="p">,</span> <span class="p">:])</span> <span class="o">+</span> <span class="n">X</span><span class="p">)</span>
            <span class="n">S2</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">nq</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">F</span><span class="p">))</span>

            <span class="c1"># S2 = block_diag(np.eye(self.n - nq), np.linalg.inv(wQ[indList, :]))</span>
            <span class="n">R2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">S2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="n">R2</span> <span class="o">=</span> <span class="n">S2</span>

        <span class="k">return</span> <span class="n">S2</span><span class="p">,</span> <span class="n">R2</span>

    <span class="k">def</span> <span class="nf">transform3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Third transformation of the coordinates that scales the modes.</span>
<span class="sd">        output:</span>
<span class="sd">            --  R3: Third transformation of charge operators (self.n,self.n)</span>
<span class="sd">            --  S3: Third transformation of flux operators (self.n,self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">S3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>

            <span class="c1"># for the charge basis</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])):</span>
                        <span class="c1"># check if abs(A[i,j]/s is either zero or one with 1e-11 accuracy</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1e-11</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1e-11</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This solver cannot solve your circuit.&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-11</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">S3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s</span>

                <span class="c1"># correcting the cInvRotated values</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span>
            <span class="c1"># for harmonic modes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># note: alpha here is absolute value of alpha( alpha is pure imaginary)</span>
                <span class="c1"># alpha for j-th mode</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">phPar</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">][</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mf">1e-11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-11</span><span class="p">:</span>
                    <span class="c1"># find the coefficient in wTrans for j-th mode that has maximum alpha</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="n">j</span><span class="p">])</span>
                    <span class="c1"># scale that mode with s</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span>
                    <span class="n">S3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">s</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># scale the uncoupled mode</span>
                    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S1</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S2</span><span class="p">)</span>

                    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">S</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>

                    <span class="n">S3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">s</span>

        <span class="n">R3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S3</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S3</span><span class="p">,</span> <span class="n">R3</span>

    <span class="k">def</span> <span class="nf">transformHamil</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        transform the Hamiltonian of the circuit that can be expressed</span>
<span class="sd">        in charge and Fock bases</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the first transformation:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform1</span><span class="p">()</span>
        <span class="c1"># second transformation</span>

        <span class="c1"># natural frequencies of the circuit(zero for modes in charge basis)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">))</span>

        <span class="c1"># set the external charge for each charge mode.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extCharge</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">Charge</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>

        <span class="c1"># the case that circuit has no JJ</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># get the second transformation:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S1</span><span class="p">)</span>

            <span class="c1"># apply the second transformation on self.cInvTrans</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span>

            <span class="c1"># get the transformed W matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S1</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">countJJnoInd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># wQ = self.wTrans[:, self.omega == 0]</span>
            <span class="c1"># wQ[np.abs(wQ) &lt; 0.98] = 0</span>
            <span class="c1"># self.wTrans[:, self.omega == 0] = wQ</span>

            <span class="c1"># scaling the modes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform3</span><span class="p">()</span>

            <span class="c1"># The final transformations are:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S1</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S2</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">S3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R3</span>

            <span class="c1"># self.cTrans = np.linalg.inv(self.cInvTrans)</span>

<div class="viewcode-block" id="Circuit.description"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.description">[docs]</a>    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_test</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print out Hamiltonian and a listing of the modes (whether they are harmonic or</span>
<span class="sd">        charge modes with the frequency for each harmonic mode), Hamiltonian parameters, and external flux values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            tp: str</span>
<span class="sd">                If ``None`` prints out the output as Latex if SQcircuit is running in a Jupyter notebook and as text</span>
<span class="sd">                if SQcircuit is running in Python terminal. If ``tp`` is ``&quot;ltx&quot;``, the output is in Latex format</span>
<span class="sd">                if ``tp`` is ``&quot;txt&quot;`` the output is in text format.</span>
<span class="sd">            _test: bool</span>
<span class="sd">                if True, return the entire description as string text. (use only for testing the function)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isNotebook</span><span class="p">():</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="n">HamilTxt</span><span class="p">(</span><span class="s1">&#39;ltx&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="n">HamilTxt</span><span class="p">(</span><span class="s1">&#39;txt&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="n">HamilTxt</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>

        <span class="n">hamilTxt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
        <span class="n">harDim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">chDim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indElemLst</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">EJLst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ELLst</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">harDim</span><span class="p">):</span>
            <span class="n">hamilTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">omega</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">ad</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">a</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chDim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chDim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">hamilTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">Ec</span><span class="p">(</span><span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">harDim</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">harDim</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>

        <span class="n">countWJJ</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">countJJ</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">countInd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">edgeVisited</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">JJHamilTxt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">indHamilTxt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indElemLst</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Junction</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edgeVisited</span><span class="p">:</span>
                    <span class="n">countWJJ</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">edgeVisited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                <span class="n">EJLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">phPar</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
                <span class="n">junTxt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">Ej</span><span class="p">(</span><span class="n">countJJ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span>
                <span class="n">junTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">txt</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">W</span><span class="p">[</span><span class="n">countWJJ</span><span class="p">,</span> <span class="p">:])</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">txt</span><span class="o">.</span><span class="n">phiExt</span><span class="p">,</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">st</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">JJHamilTxt</span> <span class="o">+=</span> <span class="n">junTxt</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
                <span class="n">countJJ</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">ELLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">energy</span><span class="p">())</span>
                <span class="n">countInd</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">indTxt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">El</span><span class="p">(</span><span class="n">countInd</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">harDim</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">indTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">txt</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)(&quot;</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">txt</span><span class="o">.</span><span class="n">phiExt</span><span class="p">,</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">indHamilTxt</span> <span class="o">+=</span> <span class="n">indTxt</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>

        <span class="n">hamilTxt</span> <span class="o">+=</span> <span class="n">indHamilTxt</span> <span class="o">+</span> <span class="n">JJHamilTxt</span>

        <span class="k">if</span> <span class="s1">&#39;+&#39;</span> <span class="ow">in</span> <span class="n">hamilTxt</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">hamilTxt</span> <span class="o">=</span> <span class="n">hamilTxt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">modeTxt</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">harDim</span><span class="p">):</span>
            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">har</span><span class="p">()</span>

            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">zp</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> \
                       <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">a</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;+&quot;</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">ad</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

            <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">phPar</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
            <span class="n">zp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">phPar</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
            <span class="n">zpTxt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:.2e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zp</span><span class="p">)</span>

            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">omega</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> \
                       <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">zp</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="n">zpTxt</span>

            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chDim</span><span class="p">):</span>
            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">ch</span><span class="p">()</span>
            <span class="n">ng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extCharge</span><span class="p">[</span><span class="n">harDim</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">ng</span><span class="p">(</span><span class="n">harDim</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>
            <span class="n">modeTxt</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">paramTxt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">param</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chDim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chDim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">paramTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">Ec</span><span class="p">(</span><span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">harDim</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">Ec</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">e</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span>
                            <span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">harDim</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">Ec</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">e</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span>
                            <span class="n">harDim</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">harDim</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>

                    <span class="n">paramTxt</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Ec</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ELLst</span><span class="p">)):</span>
            <span class="n">paramTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">El</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ELLst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EJLst</span><span class="p">)):</span>
            <span class="n">paramTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">Ej</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">EJLst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>
        <span class="n">paramTxt</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">loopTxt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)):</span>
            <span class="n">phiExt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">loopTxt</span> <span class="o">+=</span> <span class="n">txt</span><span class="o">.</span><span class="n">phiExt</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tPi</span><span class="p">()</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">eq</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">phiExt</span><span class="p">)</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">tab</span><span class="p">()</span>

        <span class="n">finalTxt</span> <span class="o">=</span> <span class="n">hamilTxt</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">line</span> <span class="o">+</span> <span class="n">modeTxt</span> <span class="o">+</span> <span class="n">txt</span><span class="o">.</span><span class="n">line</span> <span class="o">+</span> <span class="n">paramTxt</span> <span class="o">+</span> <span class="n">loopTxt</span>

        <span class="n">txt</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">finalTxt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_test</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">finalTxt</span></div>

<div class="viewcode-block" id="Circuit.loopDescription"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.loopDescription">[docs]</a>    <span class="k">def</span> <span class="nf">loopDescription</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print out the external flux distribution over inductive elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># maximum length of element ID strings</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">idStr</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indElemLst</span><span class="p">])</span>

        <span class="c1"># maximum length of loop ID strings</span>
        <span class="n">nh</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">idStr</span><span class="p">)</span> <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">])</span>

        <span class="c1"># number of loops</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)</span>

        <span class="c1"># space between elements in rows</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="mi">5</span>

        <span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">+</span> <span class="n">ns</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;, b1:&quot;</span><span class="p">))</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nl</span><span class="p">):</span>
            <span class="n">lp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="n">nh</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">idStr</span><span class="p">))</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">idStr</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">el</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indElemLst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">idStr</span>
            <span class="n">row</span> <span class="o">=</span> <span class="nb">id</span> <span class="o">+</span> <span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
            <span class="n">bStr</span> <span class="o">=</span> <span class="s2">&quot;, b</span><span class="si">{}</span><span class="s2">:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">+=</span> <span class="n">bStr</span>
            <span class="n">row</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ns</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;, b1:&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">bStr</span><span class="p">))</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nl</span><span class="p">):</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">row</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="n">nh</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span></div>

<div class="viewcode-block" id="Circuit.truncationNumbers"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.truncationNumbers">[docs]</a>    <span class="k">def</span> <span class="nf">truncationNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truncNum</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the truncation numbers for each mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            truncNum: list</span>
<span class="sd">                A list that contains the truncation numbers for each mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">error1</span> <span class="o">=</span> <span class="s2">&quot;The input must be be a python list&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">truncNum</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="n">error1</span>
        <span class="n">error2</span> <span class="o">=</span> <span class="s2">&quot;The number of modes(length of the input) must be equal to the number of nodes&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">truncNum</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">error2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">truncNum</span>

        <span class="c1"># squeeze the mode with truncation number equal to 1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">chargeOpList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numOpList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeByChargeList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxOpList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildOpMemory</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">HLC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLCHamil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeByChargeList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numOpList</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">HJJExpList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">HJJExpRootList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHJJExp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wTrans</span><span class="p">)</span></div>

<div class="viewcode-block" id="Circuit.chargeOffset"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.chargeOffset">[docs]</a>    <span class="k">def</span> <span class="nf">chargeOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ng</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;set the charge offset for each charge mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mode: int</span>
<span class="sd">                An integer that specifies the charge mode. To see, which mode is a charge mode, one</span>
<span class="sd">                can use `description()` method.</span>
<span class="sd">            ng: float</span>
<span class="sd">                The charge offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;Mode number should be an integer&quot;</span>
        <span class="k">assert</span> <span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extCharge</span><span class="p">,</span> <span class="s2">&quot;The specified mode is not a charge mode.&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extCharge</span><span class="p">[</span><span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setOffset</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extCharge</span><span class="p">[</span><span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setOffset</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chargeOpList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numOpList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeByChargeList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxOpList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildOpMemory</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">HLC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLCHamil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeByChargeList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numOpList</span><span class="p">)</span></div>

<div class="viewcode-block" id="Circuit.chargeNoise"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.chargeNoise">[docs]</a>    <span class="k">def</span> <span class="nf">chargeNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;set the charge noise for each charge mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mode: int</span>
<span class="sd">                An integer that specifies the charge mode. To see, which mode is a charge mode, one</span>
<span class="sd">                can use `description()` method.</span>
<span class="sd">            A: float</span>
<span class="sd">                The charge noise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;Mode number should be an integer&quot;</span>
        <span class="k">assert</span> <span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extCharge</span><span class="p">,</span> <span class="s2">&quot;The specified mode is not a charge mode.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extCharge</span><span class="p">[</span><span class="n">mode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setNoise</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">buildOpMemory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lTrans</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">cInvTrans</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">omega</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        build the charge operators, number operators, and cross multiplication of</span>
<span class="sd">        charge operators.</span>
<span class="sd">        inputs:</span>
<span class="sd">            -- lTrans: diagonalized inductance matrix (self.n,self.n)</span>
<span class="sd">            -- cInvTrans: diagonalized inverse of capacitance matrix (self.n,self.n)</span>
<span class="sd">            -- omega: natural frequencies of the circuit (self.n)</span>
<span class="sd">        outputs:</span>
<span class="sd">            -- chargeOpList : list of charge operators (self.n)</span>
<span class="sd">            -- fluxOpList: list of flux operators (self.n)</span>
<span class="sd">            -- chargeByChargeList : cross multiplication of charge operators as list</span>
<span class="sd">            -- numOpList : list of number operators (self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">chargeOpList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fluxOpList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">numOpList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">chargeByChargeList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># list of charge operators in their own mode basis</span>
        <span class="c1"># (tensor product of other modes are not applied yet!)</span>
        <span class="n">QList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Q0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">e</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span><span class="p">))</span> <span class="o">*</span> <span class="n">q</span><span class="o">.</span><span class="n">charge</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> \
                     <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">e</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">extCharge</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coef</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
                <span class="n">Q0</span> <span class="o">=</span> <span class="n">coef</span> <span class="o">*</span> <span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">q</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">QList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q0</span><span class="p">)</span>

        <span class="n">fluxList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># list of flux operators in their own mode basis</span>
        <span class="c1"># (tensor product of other modes are not applied yet!)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flux0</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">lTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
                <span class="n">flux0</span> <span class="o">=</span> <span class="n">coef</span> <span class="o">*</span> <span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">q</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">fluxList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flux0</span><span class="p">)</span>

        <span class="c1"># list of number operators in their own mode basis</span>
        <span class="c1"># (tensor product of other modes are not applied yet!)</span>
        <span class="n">nList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num0</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">charge</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num0</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">nList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">chargeRowList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="c1"># find the appropriate charge and number operator for first mode</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">Q2</span> <span class="o">=</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">nList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">fluxList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                    <span class="c1"># Tensor product the charge with I for other modes</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">Q2</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q2</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="n">chargeRowList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q2</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">I</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">I</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">I</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">I</span>

                <span class="c1"># find the rest of the modes</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">I</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">Q2</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">nList</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">fluxList</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                    <span class="c1"># Tensor product the charge with I for other modes</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">Q2</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q2</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="n">chargeRowList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q2</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">QQ</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">QList</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                    <span class="c1"># Tensor product the QQ with I for other modes</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">QQ</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="n">chargeRowList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>

                    <span class="n">I</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

            <span class="n">chargeOpList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
            <span class="n">numOpList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="n">chargeByChargeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chargeRowList</span><span class="p">)</span>
            <span class="n">fluxOpList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">chargeOpList</span><span class="p">,</span> <span class="n">numOpList</span><span class="p">,</span> <span class="n">chargeByChargeList</span><span class="p">,</span> <span class="n">fluxOpList</span>

    <span class="k">def</span> <span class="nf">getLCHamil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cInvTrans</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">omega</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">chargeByChargeList</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">numOpList</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the LC part of the Hamiltonian</span>
<span class="sd">        inputs:</span>
<span class="sd">            --  cInvTrans: diagonalized inverse of capacitance matrix (self.n,self.n)</span>
<span class="sd">            -- chargeByChargeList: cross multiplication of charge operators as list</span>
<span class="sd">            -- list of number operators (self.n)</span>
<span class="sd">            -- omega: natural frequencies of the circuit (self.n)</span>
<span class="sd">        outputs:</span>
<span class="sd">            -- HLC: LC part of the Hamiltonian (qutip Object)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">HLC</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># we write j in this form because of chargeByChargeList shape</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">HLC</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">chargeByChargeList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">HLC</span> <span class="o">+=</span> <span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">numOpList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">HLC</span> <span class="o">+=</span> <span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">chargeByChargeList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">HLC</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">chargeDisp</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return charge displacement operator with size N.</span>
<span class="sd">        input:</span>
<span class="sd">            -- N: size of the Hilbert Space</span>
<span class="sd">        output:</span>
<span class="sd">            -- d: charge displace ment operator( qutip object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">getHJJExp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cInvTrans</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">lTrans</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">omega</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">wTrans</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Each cosine potential of the Josephson Junction can be written as summation of two</span>
<span class="sd">        exponential terms,cos(x)=(exp(ix)+exp(-ix))/2. This function returns the quantum</span>
<span class="sd">        operators for only one exponential term.</span>
<span class="sd">        inputs:</span>
<span class="sd">            -- lTrans: diagonalized inductance matrix (self.n,self.n)</span>
<span class="sd">            -- cInvTrans: diagonalized inverse of capacitance matrix (self.n,self.n)</span>
<span class="sd">            -- omega: natural frequencies of the circuit (self.n)</span>
<span class="sd">            -- wTrans: transformed W matrix (nJ,self.n)</span>
<span class="sd">        outputs:</span>
<span class="sd">            -- HJJExpList: List of exponential part of the Josephson Junction cosine (nJ)</span>
<span class="sd">            -- HJJExpHalfList: List of square root of exponential part of</span>
<span class="sd">                               the Josephson Junction cosine (nJ)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">HJJExpList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">HJJExpRootList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># number of Josephson Junctions</span>
        <span class="n">nJ</span> <span class="o">=</span> <span class="n">wTrans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">H</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># for calculating sin(phi/2) operator for quasi-particle loss decay rate</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nJ</span><span class="p">):</span>

            <span class="c1"># tensor multiplication of displacement operator for JJ Hamiltonian</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">I</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">I</span>
                    <span class="k">elif</span> <span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeDisp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="c1"># not correct just to avoid error:</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">I</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeDisp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
                        <span class="c1"># not correct just to avoid error:</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">I</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">phPar</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">lTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span> <span class="o">*</span> <span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">H</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">alpha</span><span class="p">)</span>
                    <span class="n">H2</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeDisp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">I</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeDisp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>
                        <span class="n">H2</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">phPar</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">lTrans</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span> <span class="o">*</span> <span class="n">wTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">H</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">alpha</span><span class="p">))</span>
                    <span class="n">H2</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

            <span class="n">HJJExpList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
            <span class="n">HJJExpRootList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">HJJExpList</span><span class="p">,</span> <span class="n">HJJExpRootList</span>

    <span class="k">def</span> <span class="nf">indHamil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HJJExpList</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">HJJExpRootList</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>

        <span class="n">countInd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">countJJ</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">JJFlag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">junctionHamil</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cos&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;sin&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;sinHalf&#39;</span><span class="p">:</span> <span class="p">{}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inductorHamil</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="c1"># elements of the edge</span>
            <span class="n">edgeElements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">edgeElements</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Inductor</span><span class="p">):</span>

                    <span class="n">phi</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">):</span>
                        <span class="n">phi</span> <span class="o">+=</span> <span class="n">loop</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="p">[</span><span class="n">countInd</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

                    <span class="c1"># summation of the 1 over inductor values.</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">el</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">)</span>
                    <span class="n">O</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">couplingOperator</span><span class="p">(</span><span class="s2">&quot;inductive&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
                    <span class="n">O</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">]</span>
                    <span class="n">H</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">*</span> <span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">O</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span><span class="p">)</span>

                    <span class="c1"># save the operators for loss calculation</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inductorHamil</span><span class="p">[(</span><span class="n">countInd</span><span class="p">,</span> <span class="n">el</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">O</span>

                    <span class="n">countInd</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Junction</span><span class="p">):</span>

                    <span class="n">phi</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">):</span>
                        <span class="n">phi</span> <span class="o">+=</span> <span class="n">loop</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="p">[</span><span class="n">countInd</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

                    <span class="n">EJ</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">)</span>
                    <span class="n">HJ_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">EJ</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HJJExpList</span><span class="p">[</span><span class="n">countJJ</span><span class="p">]</span>
                    <span class="n">HJ_expRoot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">EJ</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HJJExpRootList</span><span class="p">[</span><span class="n">countJJ</span><span class="p">]</span>
                    <span class="n">HJ</span> <span class="o">=</span> <span class="n">HJ_exp</span> <span class="o">+</span> <span class="n">HJ_exp</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
                    <span class="n">H</span> <span class="o">-=</span> <span class="n">HJ</span>

                    <span class="c1"># save the operators for loss calculations.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">junctionHamil</span><span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">][</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="n">HJ</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">junctionHamil</span><span class="p">[</span><span class="s1">&#39;sin&#39;</span><span class="p">][(</span><span class="n">countInd</span><span class="p">,</span> <span class="n">el</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">HJ_exp</span> <span class="o">-</span> <span class="n">HJ_exp</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> <span class="o">/</span> <span class="mi">1</span><span class="n">j</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">junctionHamil</span><span class="p">[</span><span class="s1">&#39;sinHalf&#39;</span><span class="p">][</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">HJ_expRoot</span> <span class="o">-</span> <span class="n">HJ_expRoot</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> <span class="o">/</span> <span class="mi">1</span><span class="n">j</span>

                    <span class="n">countInd</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">JJFlag</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">JJFlag</span><span class="p">:</span>
                <span class="n">countJJ</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">JJFlag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">H</span>

<div class="viewcode-block" id="Circuit.diag"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.diag">[docs]</a>    <span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numEig</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Diagonalize the Hamiltonian of the circuit and return the eigenfrequencies and eigenvectors of the circuit up</span>
<span class="sd">        to specified number of eigenvalues.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            numEig: int</span>
<span class="sd">                The number of eigenvalues to output. The lower `numEig`, the faster `SQcircuit` finds</span>
<span class="sd">                the eigenvalues.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Please specify the truncation number for each mode.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">numEig</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;The numEig( number of eigenvalues) should be an integer.&quot;</span>

        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">()</span>

        <span class="c1"># get the data out of qutip variable and use sparse scipy eigen solver which is faster than</span>
        <span class="c1"># non-sparse eigen solver</span>
        <span class="n">eigenValues</span><span class="p">,</span> <span class="n">eigenVectors</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigs</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">numEig</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SR&#39;</span><span class="p">)</span>
        <span class="c1"># the output of eigen solver is not sorted</span>
        <span class="n">eigenValuesSorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">eigenValues</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="n">sortArg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">eigenValues</span><span class="p">)</span>
        <span class="n">eigenVectorsSorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">eigenVectors</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                              <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">sortArg</span><span class="p">]</span>

        <span class="c1"># store the eigenvalues and eigenvectors of the circuit Hamiltonian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hamilEigVal</span> <span class="o">=</span> <span class="n">eigenValuesSorted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hamilEigVec</span> <span class="o">=</span> <span class="n">eigenVectorsSorted</span>

        <span class="k">return</span> <span class="n">eigenValuesSorted</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">freq</span><span class="p">),</span> <span class="n">eigenVectorsSorted</span></div>

    <span class="c1">###############################################</span>
    <span class="c1"># Methods that calculate circuit properties</span>
    <span class="c1">###############################################</span>

<div class="viewcode-block" id="Circuit.coordinateTransformation"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.coordinateTransformation">[docs]</a>    <span class="k">def</span> <span class="nf">coordinateTransformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opType</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the transformation of the coordinates for each type of operators, either charge or flux.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            opType: str</span>
<span class="sd">                The type of the operators that can be either `&quot;charge&quot;` or `&quot;flux&quot;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">opType</span> <span class="o">==</span> <span class="s2">&quot;charge&quot;</span> <span class="ow">or</span> <span class="n">opType</span> <span class="o">==</span> <span class="s2">&quot;Charge&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opType</span> <span class="o">==</span> <span class="s2">&quot;flux&quot;</span> <span class="ow">or</span> <span class="n">opType</span> <span class="o">==</span> <span class="s2">&quot;Flux&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot; The input must be either </span><span class="se">\&quot;</span><span class="s2">charge</span><span class="se">\&quot;</span><span class="s2"> or </span><span class="se">\&quot;</span><span class="s2">flux</span><span class="se">\&quot;</span><span class="s2">.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Circuit.hamiltonian"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the transformed hamiltonian of the circuit as QuTiP object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Please specify the truncation number for each mode.&quot;</span>

        <span class="n">Hind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indHamil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HJJExpList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">HJJExpRootList</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">Hind</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">HLC</span>

        <span class="k">return</span> <span class="n">H</span></div>

    <span class="k">def</span> <span class="nf">tensorToModes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensorIndex</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        decomposes the tensor product space index to each mode indices. For example index 5 of the tensor</span>
<span class="sd">        product space can be decomposed to [1,0,1] modes if the truncation number for each mode is 2.</span>
<span class="sd">        inputs:</span>
<span class="sd">            -- tensorIndex: Index of tensor product space</span>
<span class="sd">        outputs:</span>
<span class="sd">            -- indList: a list of mode indices (self.n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># i-th mP element is the multiplication of the self.m elements until its i-th element</span>
        <span class="n">mP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mP</span> <span class="o">=</span> <span class="p">[</span><span class="n">mP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">mP</span>

        <span class="n">indList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">indexP</span> <span class="o">=</span> <span class="n">tensorIndex</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indexP</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">indList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">indexP</span> <span class="o">/</span> <span class="n">mP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">indexP</span> <span class="o">=</span> <span class="n">indexP</span> <span class="o">%</span> <span class="n">mP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">indList</span>

<div class="viewcode-block" id="Circuit.eigPhaseCoordinate"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.eigPhaseCoordinate">[docs]</a>    <span class="k">def</span> <span class="nf">eigPhaseCoordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eigInd</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the phase coordinate representations of the eigenvectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            eigInd: int</span>
<span class="sd">                The eigenvector index. For example, we set it to 0 for the ground state and 1</span>
<span class="sd">                for the first excited state.</span>
<span class="sd">            grid: list</span>
<span class="sd">                A list that contains the range of values of phase φ for which we want to evaluate the</span>
<span class="sd">                wavefunction.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eigInd</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;The eigInd( eigen index) should be an integer.&quot;</span>

        <span class="n">phiList</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grid</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)]</span>

        <span class="c1"># The total dimension of the circuit Hilbert Space</span>
        <span class="n">netDimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>

        <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">netDimension</span><span class="p">):</span>

            <span class="c1"># decomposes the tensor product space index (i) to each mode indices as a list</span>
            <span class="n">indList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorToModes</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamilEigVec</span><span class="p">[</span><span class="n">eigInd</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>

                <span class="c1"># mode number related to that node</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">indList</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>

                <span class="c1"># For charge basis</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">term</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phiList</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
                <span class="c1"># For harmonic basis</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">mode</span><span class="p">,</span> <span class="n">mode</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lTrans</span><span class="p">[</span><span class="n">mode</span><span class="p">,</span> <span class="n">mode</span><span class="p">]))</span>

                    <span class="n">coef</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">/</span> <span class="n">phPar</span><span class="o">.</span><span class="n">Phi0</span><span class="p">)</span>

                    <span class="n">term</span> <span class="o">*=</span> <span class="n">coef</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">phiList</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
                            <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">eval_hermite</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">phiList</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">Phi0</span> <span class="o">/</span> <span class="n">x0</span><span class="p">)</span>

            <span class="n">state</span> <span class="o">+=</span> <span class="n">term</span>

        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1"># transposing the first two modes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indModes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
            <span class="n">indModes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">indModes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">indModes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">state</span></div>

<div class="viewcode-block" id="Circuit.couplingOperator"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.couplingOperator">[docs]</a>    <span class="k">def</span> <span class="nf">couplingOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copType</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the capacitive or inductive coupling operator related to the specified nodes. The output has the</span>
<span class="sd">        QuTip object format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            copType: str</span>
<span class="sd">                Coupling type which is either `&quot;capacitive&quot;` or `&quot;inductive&quot;`.</span>
<span class="sd">            nodes: tuple</span>
<span class="sd">                A tuple of circuit nodes to which we want to couple.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error</span> <span class="o">=</span> <span class="s2">&quot;The coupling type must be either </span><span class="se">\&quot;</span><span class="s2">capacitive</span><span class="se">\&quot;</span><span class="s2"> or </span><span class="se">\&quot;</span><span class="s2">inductive</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="n">copType</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;capacitive&quot;</span><span class="p">,</span> <span class="s2">&quot;inductive&quot;</span><span class="p">],</span> <span class="n">error</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;Nodes must be either a list or a set.&quot;</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>

        <span class="n">node1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># for the case that we have ground in the edge</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node1</span> <span class="o">+</span> <span class="n">node2</span>
            <span class="k">if</span> <span class="n">copType</span> <span class="o">==</span> <span class="s2">&quot;capacitive&quot;</span><span class="p">:</span>
                <span class="c1"># K = np.linalg.inv(self.getMatC()) @ self.R</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">K</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeOpList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">copType</span> <span class="o">==</span> <span class="s2">&quot;inductive&quot;</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">K</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxOpList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copType</span> <span class="o">==</span> <span class="s2">&quot;capacitive&quot;</span><span class="p">:</span>
                <span class="c1"># K = np.linalg.inv(self.getMatC()) @ self.R</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">node2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">K</span><span class="p">[</span><span class="n">node1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeOpList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">copType</span> <span class="o">==</span> <span class="s2">&quot;inductive&quot;</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">node1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">K</span><span class="p">[</span><span class="n">node2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxOpList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># squeezing the dimension</span>
        <span class="n">op</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">op</span></div>

<div class="viewcode-block" id="Circuit.matrixElements"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.matrixElements">[docs]</a>    <span class="k">def</span> <span class="nf">matrixElements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copType</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the matrix element of two eigenstates for either capacitive or inductive coupling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            copType: str</span>
<span class="sd">                Coupling type which is either `&quot;capacitive&quot;` or `&quot;inductive&quot;`.</span>
<span class="sd">            nodes: tuple</span>
<span class="sd">                A tuple of circuit nodes to which we want to couple.</span>
<span class="sd">            states: tuple</span>
<span class="sd">                A tuple of indices of eigenstates for which we want to calculate the matrix element.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">state1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamilEigVec</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">state2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamilEigVec</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># get the coupling operator</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">couplingOperator</span><span class="p">(</span><span class="n">copType</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Circuit.setTemperature"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.setTemperature">[docs]</a>    <span class="k">def</span> <span class="nf">setTemperature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the temperature of the circuit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            T: float</span>
<span class="sd">                The temperature in Kelvin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span></div>

<div class="viewcode-block" id="Circuit.setLowFreq"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.setLowFreq">[docs]</a>    <span class="k">def</span> <span class="nf">setLowFreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the low-frequency cut-off.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            value: The value of the frequency.</span>
<span class="sd">            unit: The unit of the input value in hertz unit that can be &quot;THz&quot;, &quot;GHz&quot;, &quot;MHz&quot;,and ,etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omegaLow</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">value</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">freqList</span><span class="p">[</span><span class="n">unit</span><span class="p">]</span></div>

<div class="viewcode-block" id="Circuit.setHighFreq"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.setHighFreq">[docs]</a>    <span class="k">def</span> <span class="nf">setHighFreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the high-frequency cut-off.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            value: The value of the frequency.</span>
<span class="sd">            unit: The unit of the input value in hertz unit that can be &quot;THz&quot;, &quot;GHz&quot;, &quot;MHz&quot;,and ,etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omegaHigh</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">value</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">freqList</span><span class="p">[</span><span class="n">unit</span><span class="p">]</span></div>

<div class="viewcode-block" id="Circuit.setTexp"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.setTexp">[docs]</a>    <span class="k">def</span> <span class="nf">setTexp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the measurement time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            value: The value of the measurement time.</span>
<span class="sd">            unit: The unit of the input value in time unit that can be &quot;s&quot;, &quot;ms&quot;, &quot;us&quot;,and ,etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tExp</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">timeList</span><span class="p">[</span><span class="n">unit</span><span class="p">]</span></div>

<div class="viewcode-block" id="Circuit.decRate"><a class="viewcode-back" href="../../apidoc/circuit.html#SQcircuit.Circuit.decRate">[docs]</a>    <span class="k">def</span> <span class="nf">decRate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decType</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">total</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the decoherence rate in [1/s] between each two eigenstates for different types of</span>
<span class="sd">        depolarization and dephasing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            decType: str</span>
<span class="sd">                decoherence type that can be: `&quot;capacitive&quot;` for capacitive loss; `&quot;inductive&quot;` for inductive loss;</span>
<span class="sd">                `&quot;quasiparticle&quot;` for quasiparticle loss; `&quot;charge&quot;` for charge noise, `&quot;flux&quot;` for flux noise; and</span>
<span class="sd">                `&quot;cc&quot;` for critical current noise.</span>
<span class="sd">            states: tuple</span>
<span class="sd">                A tuple of indices of eigenstates for which we want to calculate the decoherence rate. For example,</span>
<span class="sd">                for `states=(0,1)`, we calculate the decoherence rate between the ground state and the first excited</span>
<span class="sd">                state.</span>
<span class="sd">            total:</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">omega1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamilEigVal</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">omega2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamilEigVal</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">state1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamilEigVec</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">state2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamilEigVec</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">omega2</span> <span class="o">-</span> <span class="n">omega1</span><span class="p">)</span>

        <span class="n">decay</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># prevent the exponential overflow(exp(709) is the biggest number that numpy can calculate)</span>
        <span class="k">if</span> <span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">/</span> <span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">k_B</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">709</span><span class="p">:</span>
            <span class="n">down</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">up</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">/</span> <span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">k_B</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">down</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">up</span> <span class="o">=</span> <span class="n">down</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span>

        <span class="c1"># for temperature dependent loss</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">total</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">tempS</span> <span class="o">=</span> <span class="n">down</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tempS</span> <span class="o">=</span> <span class="n">up</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tempS</span> <span class="o">=</span> <span class="n">down</span> <span class="o">+</span> <span class="n">up</span>

        <span class="k">if</span> <span class="n">decType</span> <span class="o">==</span> <span class="s2">&quot;capacitive&quot;</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">edge</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Capacitor</span><span class="p">):</span>
                        <span class="n">cap</span> <span class="o">=</span> <span class="n">el</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cap</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">cap</span>

                    <span class="k">if</span> <span class="n">cap</span><span class="o">.</span><span class="n">Q</span><span class="p">:</span>
                        <span class="n">decay</span> <span class="o">+=</span> <span class="n">tempS</span> <span class="o">*</span> <span class="n">cap</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">/</span> <span class="n">cap</span><span class="o">.</span><span class="n">Q</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrixElements</span><span class="p">(</span>
                            <span class="s2">&quot;capacitive&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">states</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">decType</span> <span class="o">==</span> <span class="s2">&quot;inductive&quot;</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">indx</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inductorHamil</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inductorHamil</span><span class="p">[(</span><span class="n">indx</span><span class="p">,</span> <span class="n">el</span><span class="p">)]</span>
                <span class="n">op</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">Q</span><span class="p">:</span>
                    <span class="n">decay</span> <span class="o">+=</span> <span class="n">tempS</span> <span class="o">/</span> <span class="n">el</span><span class="o">.</span><span class="n">Q</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">decType</span> <span class="o">==</span> <span class="s2">&quot;quasiparticle&quot;</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctionHamil</span><span class="p">[</span><span class="s1">&#39;sinHalf&#39;</span><span class="p">]:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctionHamil</span><span class="p">[</span><span class="s1">&#39;sinHalf&#39;</span><span class="p">][</span><span class="n">el</span><span class="p">]</span>
                <span class="n">op</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">]</span>

                <span class="c1"># Delta = 0.00025 * 1.6e-19</span>
                <span class="c1"># Y = el.x_qp * 8 * phPar.hbar / np.pi / phPar.hbar * np.sqrt(2 * Delta / phPar.hbar / omega)</span>

                <span class="n">decay</span> <span class="o">+=</span> <span class="n">tempS</span> <span class="o">*</span> <span class="n">el</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">omega</span> \
                         <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">decType</span> <span class="o">==</span> <span class="s2">&quot;charge&quot;</span><span class="p">:</span>

            <span class="c1"># first derivative of the Hamiltonian with respect to charge noise</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">Qobj</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">op</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cInvTrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chargeOpList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span><span class="p">)</span>
                    <span class="n">op</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">]</span>
                    <span class="n">partialOmega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">state2</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state2</span> <span class="o">-</span> <span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="n">decay</span> <span class="o">+=</span> <span class="n">partialOmega</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extCharge</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">e</span><span class="p">)</span> \
                             <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegaLow</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tExp</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="n">decType</span> <span class="o">==</span> <span class="s2">&quot;cc&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctionHamil</span><span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">]:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctionHamil</span><span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">][</span><span class="n">el</span><span class="p">]</span>
                <span class="n">op</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">]</span>
                <span class="n">partialOmega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">state2</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state2</span> <span class="o">-</span> <span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">decay</span> <span class="o">+=</span> <span class="n">partialOmega</span> <span class="o">*</span> <span class="n">el</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegaLow</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tExp</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="n">decType</span> <span class="o">==</span> <span class="s2">&quot;flux&quot;</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">indx</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inductorHamil</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inductorHamil</span><span class="p">[(</span><span class="n">indx</span><span class="p">,</span> <span class="n">el</span><span class="p">)]</span>
                <span class="n">op</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">]</span>
                <span class="n">partialOmega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">state2</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state2</span> <span class="o">-</span> <span class="n">state1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span> <span class="o">*</span> <span class="n">state1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>

                <span class="n">A</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">+=</span> <span class="n">loop</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">phPar</span><span class="o">.</span><span class="n">Phi0</span>

                <span class="n">decay</span> <span class="o">+=</span> <span class="n">partialOmega</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegaLow</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tExp</span><span class="p">)))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">phPar</span><span class="o">.</span><span class="n">hbar</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">decay</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Taha Rajabzadeh, Amir Safavi-Naeini.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>